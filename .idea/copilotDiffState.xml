<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/public/index.html">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/public/index.html" />
              <option name="originalContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;it&quot;&gt;&#10;  &lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot; /&gt;&#10;    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&#10;    &lt;title&gt;Curiow&lt;/title&gt;&#10;    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;&#10;    &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/heroicons/2.1.3/24/outline/heroicons.min.css&quot; rel=&quot;stylesheet&quot;&gt;&#10;  &lt;script type=&quot;importmap&quot;&gt;&#10;{&#10;  &quot;imports&quot;: {&#10;    &quot;react-dom/&quot;: &quot;https://esm.sh/react-dom@^19.1.1/&quot;,&#10;    &quot;@google/genai&quot;: &quot;https://esm.sh/@google/genai@^1.13.0&quot;,&#10;    &quot;react/&quot;: &quot;https://esm.sh/react@^19.1.1/&quot;,&#10;    &quot;react&quot;: &quot;https://esm.sh/react@^19.1.1&quot;,&#10;    &quot;firebase/app&quot;: &quot;https://esm.sh/firebase@10.12.2/app&quot;,&#10;    &quot;firebase/auth&quot;: &quot;https://esm.sh/firebase@10.12.2/auth&quot;,&#10;    &quot;firebase/firestore&quot;: &quot;https://esm.sh/firebase@10.12.2/firestore&quot;,&#10;    &quot;firebase/&quot;: &quot;https://esm.sh/firebase@^12.1.0/&quot;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt;&#10;&lt;/head&gt;&#10;  &lt;body class=&quot;bg-slate-50 dark:bg-slate-900&quot;&gt;&#10;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#10;    &lt;script type=&quot;module&quot; src=&quot;/index.tsx&quot;&gt;&lt;/script&gt;&#10;  &lt;/body&gt;&#10;&lt;/html&gt;" />
              <option name="updatedContent" value="&lt;!DOCTYPE html&gt;&#10;&lt;html lang=&quot;it&quot;&gt;&#10;  &lt;head&gt;&#10;    &lt;meta charset=&quot;UTF-8&quot; /&gt;&#10;    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;&#10;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&#10;    &lt;title&gt;Curiow&lt;/title&gt;&#10;    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;&#10;    &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/heroicons/2.1.3/24/outline/heroicons.min.css&quot; rel=&quot;stylesheet&quot;&gt;&#10;  &lt;script type=&quot;importmap&quot;&gt;&#10;{&#10;  &quot;imports&quot;: {&#10;    &quot;react-dom/&quot;: &quot;https://esm.sh/react-dom@^19.1.1/&quot;,&#10;    &quot;@google/genai&quot;: &quot;https://esm.sh/@google/genai@^1.13.0&quot;,&#10;    &quot;react/&quot;: &quot;https://esm.sh/react@^19.1.1/&quot;,&#10;    &quot;react&quot;: &quot;https://esm.sh/react@^19.1.1&quot;,&#10;    &quot;firebase/app&quot;: &quot;https://esm.sh/firebase@10.12.2/app&quot;,&#10;    &quot;firebase/auth&quot;: &quot;https://esm.sh/firebase@10.12.2/auth&quot;,&#10;    &quot;firebase/firestore&quot;: &quot;https://esm.sh/firebase@10.12.2/firestore&quot;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt;&#10;&lt;/head&gt;&#10;  &lt;body class=&quot;bg-slate-50 dark:bg-slate-900&quot;&gt;&#10;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#10;    &lt;script type=&quot;module&quot; src=&quot;/index.tsx&quot;&gt;&lt;/script&gt;&#10;  &lt;/body&gt;&#10;&lt;/html&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/public/videos/curiow-feed.mp4">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/public/videos/curiow-feed.mp4" />
              <option name="updatedContent" value="# Placeholder video file - replace with actual video showcasing Curiow's feed features" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/public/videos/curiow-intro.mp4">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/public/videos/curiow-intro.mp4" />
              <option name="updatedContent" value="# Placeholder video file - replace with actual video&#10;# This would be a video showcasing Curiow's main features" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/GemDetailView.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/GemDetailView.tsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useRef } from 'react';&#10;import { Gem, UserQuestion, User, Filter, Channel } from '../types';&#10;import { ChevronLeftIcon, HeartIcon, ShareIcon, PaperAirplaneIcon, SparklesIcon, PlusCircleIcon, TagIcon, LinkIcon, ChevronDownIcon, LightBulbIcon, BookOpenIcon, FacebookIcon, InstagramIcon, WhatsappIcon, MailIcon, CopyIcon } from './icons';&#10;import { trackEvent, getIdToken } from '../services/firebase';&#10;import { usePageMeta } from '../hooks/usePageMeta';&#10;import Header from './Header';&#10;&#10;interface GemDetailViewProps {&#10;  gem: Gem;&#10;  isFavorite: boolean;&#10;  isLoggedIn: boolean;&#10;  user?: User | null;&#10;  onBack: () =&gt; void;&#10;  onSaveRequest: (gemId: string) =&gt; void;&#10;  onRemoveRequest: (gemId: string) =&gt; void;&#10;  onAddUserQuestion: (gemId: string, question: string) =&gt; void;&#10;  onTagSelect: (tag: string) =&gt; void;&#10;  onLogin: () =&gt; void;&#10;  onLogout: () =&gt; void;&#10;  onNavigate: (view: 'feed' | 'saved' | 'profile' | 'dashboard' | 'topics') =&gt; void;&#10;  selectedFilter?: Filter;&#10;  onSelectFilter?: (filter: Filter) =&gt; void;&#10;  channels?: Channel[];&#10;}&#10;&#10;const UserQuestionItem: React.FC&lt;{ userQuestion: UserQuestion }&gt; = ({ userQuestion }) =&gt; (&#10;    &lt;div className=&quot;mt-4 p-4 bg-slate-100 dark:bg-slate-800 rounded-lg&quot;&gt;&#10;        &lt;p className=&quot;font-semibold text-sm text-slate-600 dark:text-slate-300&quot;&gt;Domanda: &lt;span className=&quot;font-normal&quot;&gt;{userQuestion.question}&lt;/span&gt;&lt;/p&gt;&#10;        &lt;div className=&quot;mt-2 text-sm text-slate-800 dark:text-slate-200&quot;&gt;&#10;            {userQuestion.isGenerating ? (&#10;                 &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                    &lt;SparklesIcon className=&quot;w-4 h-4 animate-pulse text-indigo-400&quot; /&gt;&#10;                    &lt;span&gt;Generazione risposta...&lt;/span&gt;&#10;                &lt;/div&gt;&#10;            ) : (&#10;                &lt;p className=&quot;whitespace-pre-wrap&quot;&gt;{userQuestion.answer}&lt;/p&gt;&#10;            )}&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;);&#10;&#10;const GemDetailView: React.FC&lt;GemDetailViewProps&gt; = ({ gem, isFavorite, onBack, onSaveRequest, onRemoveRequest, onAddUserQuestion, onTagSelect, isLoggedIn, user, onLogin, onLogout, onNavigate, selectedFilter, onSelectFilter, channels }) =&gt; {&#10;  const [userQuestion, setUserQuestion] = useState('');&#10;  const [isSourcesOpen, setIsSourcesOpen] = useState(false);&#10;  const [hasAutoScrolled, setHasAutoScrolled] = useState(false);&#10;  const imgRef = useRef&lt;HTMLImageElement | null&gt;(null);&#10;  // nuovo stato per tab&#10;  const [activeTab, setActiveTab] = useState&lt;'tips' | 'saggio'&gt;('tips');&#10;  // refs per animazione cross-fade&#10;  const tipsRef = useRef&lt;HTMLDivElement | null&gt;(null);&#10;  const saggioRef = useRef&lt;HTMLDivElement | null&gt;(null);&#10;  const [contentHeight, setContentHeight] = useState&lt;number&gt;(0);&#10;  const [showShareBar, setShowShareBar] = useState(false);&#10;&#10;  const currentUrl = typeof window !== 'undefined' ? `${window.location.origin}/gem/${gem.id}` : '';&#10;  const rawSummary: string = (gem as any)?.content?.summary || '';&#10;  const rawDescription: string = (gem as any)?.content?.description || '';&#10;  const baseText = rawSummary || rawDescription;&#10;  const descriptionSnippet = baseText ? baseText.replace(/\s+/g,' ').slice(0,180) : 'Gemme di conoscenza su Curiow.';&#10;  const shareText = `Scopri questa gemma su Curiow: ${gem.title}`;&#10;&#10;  usePageMeta({&#10;    title: `${gem.title} | Curiow`,&#10;    description: descriptionSnippet,&#10;    image: gem.imageUrl,&#10;    url: currentUrl,&#10;    type: 'article'&#10;  });&#10;&#10;  const handleCopyLink = async () =&gt; {&#10;    try {&#10;      await navigator.clipboard.writeText(currentUrl);&#10;    } catch {&#10;      const tmp = document.createElement('input');&#10;      tmp.value = currentUrl; document.body.appendChild(tmp); tmp.select(); document.execCommand('copy'); document.body.removeChild(tmp);&#10;    }&#10;    trackEvent('share', { channel: 'copy_link', gem_id: gem.id });&#10;    alert('Link copiato!');&#10;  };&#10;&#10;  const handleNativeShare = async () =&gt; {&#10;    if (navigator.share) {&#10;      trackEvent('share_attempt', { channel: 'web_share', gem_id: gem.id });&#10;      try {&#10;        await navigator.share({ title: gem.title, text: shareText, url: currentUrl });&#10;        trackEvent('share', { channel: 'web_share', gem_id: gem.id });&#10;      } catch { /* annullato */ }&#10;    } else {&#10;      handleCopyLink();&#10;    }&#10;  };&#10;&#10;  const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(currentUrl)}`;&#10;  const whatsappUrl = `https://api.whatsapp.com/send?text=${encodeURIComponent(shareText + ' ' + currentUrl)}`;&#10;  const emailUrl = `mailto:?subject=${encodeURIComponent('Consiglio: ' + gem.title)}&amp;body=${encodeURIComponent(shareText + '\n' + currentUrl)}`;&#10;  // Instagram non ha share URL web: fallback copia link&#10;&#10;  // funzione misura altezza contenuto attivo&#10;  const measureActiveHeight = () =&gt; {&#10;    const el = activeTab === 'tips' ? tipsRef.current : saggioRef.current;&#10;    if (el) {&#10;      // usa scrollHeight per includere overflow&#10;      const h = el.scrollHeight;&#10;      setContentHeight(h);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    // misura dopo cambio tab / gem&#10;    requestAnimationFrame(() =&gt; measureActiveHeight());&#10;  }, [activeTab, gem.id]);&#10;&#10;  useEffect(() =&gt; {&#10;    // misura al resize per mantenere altezza coerente&#10;    const onResize = () =&gt; measureActiveHeight();&#10;    window.addEventListener('resize', onResize);&#10;    return () =&gt; window.removeEventListener('resize', onResize);&#10;  }, []);&#10;&#10;  // Funzione per scrollare il titolo allineandolo appena sotto l'header sticky&#10;  const scrollTitleIntoView = (smooth = false) =&gt; {&#10;    const titleEl = document.getElementById('gem-title');&#10;    if (!titleEl) return;&#10;    const headerEl = document.querySelector('header');&#10;    const headerHeight = headerEl ? (headerEl as HTMLElement).offsetHeight : 0;&#10;    const buffer = 8; // piccolo margine&#10;    const target = titleEl.getBoundingClientRect().top + window.scrollY - headerHeight - buffer;&#10;    window.scrollTo({ top: target &gt;= 0 ? target : 0, behavior: smooth ? 'smooth' : 'auto' });&#10;    setHasAutoScrolled(true);&#10;  };&#10;&#10;  // Scroll iniziale dopo mount/cambio gem (post layout)&#10;  useEffect(() =&gt; {&#10;    setHasAutoScrolled(false);&#10;    // Usa rAF per attendere layout, poi ulteriore timeout breve per carichi asincroni minimi&#10;    requestAnimationFrame(() =&gt; {&#10;      scrollTitleIntoView(false);&#10;      setTimeout(() =&gt; { if (!hasAutoScrolled) scrollTitleIntoView(false); }, 60);&#10;    });&#10;    // eslint-disable-next-line react-hooks/exhaustive-deps&#10;  }, [gem.id]);&#10;&#10;  // Se l'immagine carica dopo e non abbiamo ancora auto-scrollato, riallinea&#10;  const handleImageLoad = () =&gt; {&#10;    if (!hasAutoScrolled) scrollTitleIntoView(false);&#10;  };&#10;&#10;  const handleUserQuestionSubmit = (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (userQuestion.trim()) {&#10;      onAddUserQuestion(gem.id, userQuestion.trim());&#10;      setUserQuestion('');&#10;    }&#10;  };&#10;&#10;  const handleShare = () =&gt; {&#10;    navigator.clipboard.writeText(`Scopri questa gemma di conoscenza: &quot;${gem.title}&quot; su Curiow!`);&#10;    alert(&quot;Contenuto copiato negli appunti!&quot;);&#10;  };&#10;&#10;  const handleFilterSelect = (filter: Filter) =&gt; {&#10;    if (onSelectFilter) onSelectFilter(filter);&#10;    if (filter.type === 'channel') {&#10;      onNavigate('feed');&#10;    }&#10;  };&#10;&#10;  // --- Rendering contenuti template ---&#10;  const renderMiniThread = (content: any) =&gt; {&#10;    const steps = Array.isArray(content.steps) ? content.steps : [];&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        &lt;div className=&quot;space-y-4&quot;&gt;&#10;          {steps.map((s: any, idx: number) =&gt; (&#10;            &lt;div key={idx} className=&quot;relative pl-10&quot;&gt;&#10;              &lt;div className=&quot;absolute left-0 top-0 flex flex-col items-center&quot;&gt;&#10;                &lt;div className=&quot;w-8 h-8 rounded-full bg-indigo-600 text-white flex items-center justify-center text-sm font-semibold shadow&quot;&gt;{idx+1}&lt;/div&gt;&#10;                {idx &lt; steps.length -1 &amp;&amp; &lt;div className=&quot;flex-1 w-px bg-gradient-to-b from-indigo-400 via-indigo-300 to-transparent mt-1&quot;/&gt;}&#10;              &lt;/div&gt;&#10;              &lt;h3 className=&quot;text-lg font-semibold text-slate-900 dark:text-white&quot;&gt;{s.title}&lt;/h3&gt;&#10;              &lt;p className=&quot;mt-1 text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{s.body}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;        {content.payoff &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-emerald-500/10 via-emerald-500/5 to-indigo-500/10 border border-emerald-400/30 dark:border-emerald-400/20&quot;&gt;&#10;            &lt;div className=&quot;flex items-start&quot;&gt;&#10;              &lt;SparklesIcon className=&quot;w-6 h-6 text-emerald-500 mr-3 mt-0.5&quot;/&gt;&#10;              &lt;div&gt;&#10;                &lt;p className=&quot;text-sm uppercase tracking-wide font-semibold text-emerald-600 dark:text-emerald-400&quot;&gt;Payoff&lt;/p&gt;&#10;                &lt;p className=&quot;mt-1 font-medium text-slate-900 dark:text-slate-100 leading-relaxed&quot;&gt;{content.payoff}&lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderMythVsReality = (content: any) =&gt; {&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        &lt;div className=&quot;grid md:grid-cols-2 gap-4&quot;&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-rose-600 dark:text-rose-300&quot;&gt;Mito&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 text-rose-800 dark:text-rose-200 font-medium leading-relaxed whitespace-pre-wrap&quot;&gt;{content.myth}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800 relative overflow-hidden&quot;&gt;&#10;            &lt;div className=&quot;absolute inset-0 pointer-events-none bg-[radial-gradient(circle_at_80%_20%,rgba(16,185,129,0.15),transparent_60%)]&quot;/&gt;&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-emerald-600 dark:text-emerald-300&quot;&gt;Realtà&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 text-emerald-800 dark:text-emerald-200 font-medium leading-relaxed whitespace-pre-wrap&quot;&gt;{content.reality}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        {content.evidence &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400&quot;&gt;Evidenze&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.evidence}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.why_it_matters &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-indigo-500/10 via-violet-500/10 to-fuchsia-500/10 border border-indigo-300/30 dark:border-indigo-300/20&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-indigo-600 dark:text-indigo-300&quot;&gt;Perché conta&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 font-medium text-slate-900 dark:text-slate-100 leading-relaxed whitespace-pre-wrap&quot;&gt;{content.why_it_matters}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderFactCard = (content: any) =&gt; {&#10;    const facts: string[] = Array.isArray(content.facts) ? content.facts : [];&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-5&quot;&gt;&#10;        {content.hook &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-br from-indigo-600 to-violet-600 text-white shadow&quot;&gt;&#10;            &lt;p className=&quot;text-sm font-semibold tracking-wide uppercase opacity-90&quot;&gt;Dato Chiave&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-lg leading-snug font-bold whitespace-pre-wrap&quot;&gt;{content.hook}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {facts.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;grid gap-3&quot;&gt;&#10;            {facts.map((f, i) =&gt; (&#10;              &lt;div key={i} className=&quot;p-4 rounded-lg bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 flex&quot;&gt;&#10;                &lt;div className=&quot;mr-3 mt-0.5 text-indigo-500 font-semibold text-xs&quot;&gt;FACT {i+1}&lt;/div&gt;&#10;                &lt;p className=&quot;text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{f}&lt;/p&gt;&#10;              &lt;/div&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.implication &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-amber-700 dark:text-amber-300&quot;&gt;Implicazione&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-amber-900 dark:text-amber-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.implication}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.action &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-emerald-700 dark:text-emerald-300&quot;&gt;Azione&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm font-medium text-emerald-900 dark:text-emerald-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.action}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderProsCons = (content: any) =&gt; {&#10;    const pros: string[] = Array.isArray(content.pros) ? content.pros : [];&#10;    const cons: string[] = Array.isArray(content.cons) ? content.cons : [];&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        {content.scenario &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400&quot;&gt;Scenario&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.scenario}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        &lt;div className=&quot;grid md:grid-cols-2 gap-4&quot;&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-emerald-700 dark:text-emerald-300&quot;&gt;Pro&lt;/p&gt;&#10;            &lt;ul className=&quot;mt-2 space-y-2 text-sm text-emerald-900 dark:text-emerald-100&quot;&gt;&#10;              {pros.map((p,i)=&gt;(&lt;li key={i} className=&quot;flex&quot;&gt;&lt;span className=&quot;mr-2 text-emerald-500 font-semibold&quot;&gt;+&lt;/span&gt;&lt;span className=&quot;flex-1 whitespace-pre-wrap leading-relaxed&quot;&gt;{p}&lt;/span&gt;&lt;/li&gt;))}&#10;              {pros.length===0 &amp;&amp; &lt;li className=&quot;text-emerald-700/70 dark:text-emerald-300/60 italic&quot;&gt;Nessun pro indicato.&lt;/li&gt;}&#10;            &lt;/ul&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-rose-700 dark:text-rose-300&quot;&gt;Contro&lt;/p&gt;&#10;            &lt;ul className=&quot;mt-2 space-y-2 text-sm text-rose-900 dark:text-rose-100&quot;&gt;&#10;              {cons.map((c,i)=&gt;(&lt;li key={i} className=&quot;flex&quot;&gt;&lt;span className=&quot;mr-2 text-rose-500 font-semibold&quot;&gt;-&lt;/span&gt;&lt;span className=&quot;flex-1 whitespace-pre-wrap leading-relaxed&quot;&gt;{c}&lt;/span&gt;&lt;/li&gt;))}&#10;              {cons.length===0 &amp;&amp; &lt;li className=&quot;text-rose-700/70 dark:text-rose-300/60 italic&quot;&gt;Nessun contro indicato.&lt;/li&gt;}&#10;            &lt;/ul&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        {content.advice &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-indigo-500/10 via-sky-500/10 to-emerald-500/10 border border-indigo-300/30 dark:border-indigo-300/20&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-indigo-600 dark:text-indigo-300&quot;&gt;Sintesi / Consiglio&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 font-medium text-slate-900 dark:text-slate-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.advice}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderQuickExplainer = (content: any) =&gt; {&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        {content.analogy &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-indigo-600 text-white shadow&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide opacity-80&quot;&gt;Analogia Guida&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 text-lg font-bold leading-snug whitespace-pre-wrap&quot;&gt;{content.analogy}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.definition &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400&quot;&gt;Definizione&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.definition}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        &lt;div className=&quot;grid md:grid-cols-2 gap-4&quot;&gt;&#10;          {content.example &amp;&amp; (&#10;            &lt;div className=&quot;p-4 rounded-lg bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800&quot;&gt;&#10;              &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-emerald-700 dark:text-emerald-300&quot;&gt;Esempio&lt;/p&gt;&#10;              &lt;p className=&quot;mt-1 text-sm text-emerald-900 dark:text-emerald-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.example}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;          {content.anti_example &amp;&amp; (&#10;            &lt;div className=&quot;p-4 rounded-lg bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-800&quot;&gt;&#10;              &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-rose-700 dark:text-rose-300&quot;&gt;Non È Questo&lt;/p&gt;&#10;              &lt;p className=&quot;mt-1 text-sm text-rose-900 dark:text-rose-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.anti_example}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;        {content.takeaway &amp;&amp; (&#10;            &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-fuchsia-500/10 via-violet-500/10 to-indigo-500/10 border border-fuchsia-300/30 dark:border-fuchsia-300/20&quot;&gt;&#10;              &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-fuchsia-600 dark:text-fuchsia-300&quot;&gt;Takeaway&lt;/p&gt;&#10;              &lt;p className=&quot;mt-2 font-medium text-slate-900 dark:text-slate-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.takeaway}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderStructuredContent = () =&gt; {&#10;    const content = (gem as any).content;&#10;    if (!content || !content.template) return null;&#10;    switch (content.template) {&#10;      case 'mini_thread':&#10;        return renderMiniThread(content);&#10;      case 'myth_vs_reality':&#10;        return renderMythVsReality(content);&#10;      case 'fact_card':&#10;        return renderFactCard(content);&#10;      case 'pros_cons':&#10;        return renderProsCons(content);&#10;      case 'quick_explainer':&#10;        return renderQuickExplainer(content);&#10;      default:&#10;        return null;&#10;    }&#10;  };&#10;  // --- fine rendering contenuti template ---&#10;&#10;  // Testo completo del saggio (nuovo: può essere in gem.content.description)&#10;  const fullDescription: string | undefined = (gem as any)?.content?.description;&#10;&#10;  // Utility: segmentazione in paragrafi leggibili (solo visualizzazione)&#10;  const buildParagraphs = (text?: string): string[] =&gt; {&#10;    if (!text) return [];&#10;    const normalized = text.replace(/\r\n?/g, '\n').trim();&#10;    // Se l'autore ha già usato paragrafi (doppie newline) rispetta quelli&#10;    const explicit = normalized.split(/\n{2,}/).map(p =&gt; p.trim()).filter(Boolean);&#10;    if (explicit.length &gt; 1) return explicit;&#10;    // Altrimenti suddividi per punto + spazio + Maiuscola (mantieni il punto)&#10;    const periodSplit = normalized&#10;      // comprime whitespace multiplo a singolo spazio per consistenza&#10;      .replace(/\n+/g, ' ')&#10;      .replace(/\s{2,}/g, ' ')&#10;      .split(/(?&lt;=\.)\s+(?=[A-ZÀ-ÖØ-Ý])/)&#10;      .map(s =&gt; s.trim())&#10;      .filter(Boolean);&#10;    if (periodSplit.length &gt; 1) return periodSplit;&#10;    // fallback: ritorna intero blocco&#10;    return [normalized];&#10;  };&#10;&#10;  const paragraphs = buildParagraphs(fullDescription);&#10;&#10;  // Calcolo tempo di lettura (200 wpm medio)&#10;  const readingTime = (() =&gt; {&#10;    if (!fullDescription) return null;&#10;    const words = fullDescription.trim().split(/\s+/).filter(Boolean).length;&#10;    const WPM = 200; // media adulti IT&#10;    const minutesFloat = words / WPM;&#10;    const minutes = Math.floor(minutesFloat);&#10;    const seconds = Math.round((minutesFloat - minutes) * 60);&#10;    const display = minutes &lt; 1 ? `${seconds &lt; 10 ? '~15s' : `${seconds}s`}` : `${minutes} min${minutes === 1 ? '' : ''}${seconds &gt;= 30 &amp;&amp; minutes &lt; 10 ? ' +' : ''}`;&#10;    return { words, minutes, seconds, display };&#10;  })();&#10;&#10;  useEffect(() =&gt; {&#10;    // Log JWT Firebase solo per admin quando si accede al dettaglio di una gemma&#10;    if (user?.role === 'admin') { // confronto stringa per evitare dipendenza aggiuntiva da enum&#10;      getIdToken()&#10;        .then(token =&gt; {&#10;          if (token) {&#10;            console.log('[ADMIN][JWT] Firebase ID Token:', token);&#10;          } else {&#10;            console.log('[ADMIN][JWT] Nessun token disponibile.');&#10;          }&#10;        })&#10;        .catch(err =&gt; console.warn('[ADMIN][JWT] Errore recupero token:', err));&#10;    }&#10;  }, [user?.role, gem.id]);&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-2xl mx-auto&quot;&gt;&#10;        &lt;Header&#10;          isLoggedIn={isLoggedIn}&#10;          user={user}&#10;          onLogin={onLogin}&#10;          onLogout={onLogout}&#10;          onNavigate={onNavigate}&#10;          showFilters={true}&#10;          selectedFilter={selectedFilter}&#10;          onSelectFilter={handleFilterSelect}&#10;          channels={channels}&#10;          initialFiltersOpen={false}&#10;          onBack={onBack}&#10;        /&gt;&#10;        &lt;article&gt;&#10;            &lt;div className=&quot;p-5 sm:p-8&quot;&gt;&#10;                {/* Immagine prima */}&#10;                &lt;img ref={imgRef} src={gem.imageUrl} alt={gem.title} onLoad={handleImageLoad} className=&quot;w-full h-auto object-cover md:rounded-lg&quot; /&gt;&#10;                {/* Titolo sotto immagine (ancora) */}&#10;                &lt;h1 id=&quot;gem-title&quot; className=&quot;mt-4 text-2xl lg:text-3xl font-bold text-slate-900 dark:text-white leading-tight&quot;&gt;{gem.title}&lt;/h1&gt;&#10;&#10;                &lt;div className=&quot;mt-4 flex flex-wrap gap-x-4 gap-y-2 items-center&quot;&gt;&#10;                    &lt;button&#10;                        onClick={() =&gt; isFavorite ? onRemoveRequest(gem.id) : onSaveRequest(gem.id)}&#10;                        className=&quot;flex items-center space-x-1.5 text-slate-600 dark:text-slate-300 hover:text-red-500 dark:hover:text-red-400 transition-colors&quot;&#10;                    &gt;&#10;                        &lt;HeartIcon className={`w-6 h-6 ${isFavorite ? 'fill-red-500 text-red-500' : ''}`} /&gt;&#10;                        &lt;span className=&quot;text-sm font-medium&quot;&gt;{isFavorite ? 'Rimuovi' : 'Salva'}&lt;/span&gt;&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                        onClick={()=&gt; setShowShareBar(v=&gt;{const nv=!v; trackEvent('share_bar_toggle',{ open: nv, gem_id: gem.id }); return nv;})}&#10;                        className=&quot;flex items-center space-x-1.5 text-slate-600 dark:text-slate-300 hover:text-indigo-500 dark:hover:text-indigo-400 transition-colors&quot;&#10;                    &gt;&#10;                        &lt;ShareIcon className=&quot;w-6 h-6&quot; /&gt;&#10;                        &lt;span className=&quot;text-sm font-medium&quot;&gt;Condividi&lt;/span&gt;&#10;                    &lt;/button&gt;&#10;                    {navigator.share &amp;&amp; (&#10;                      &lt;button&#10;                        onClick={handleNativeShare}&#10;                        className=&quot;hidden sm:inline-flex items-center space-x-1.5 text-slate-500 dark:text-slate-400 hover:text-indigo-500 dark:hover:text-indigo-400 text-xs&quot;&#10;                      &gt;&#10;                        &lt;span&gt;Share rapido&lt;/span&gt;&#10;                      &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;                {showShareBar &amp;&amp; (&#10;                  &lt;div className=&quot;mt-3 flex flex-wrap gap-2 items-center animate-fade-in&quot;&gt;&#10;                    &lt;a href={facebookUrl} onClick={()=&gt;trackEvent('share',{channel:'facebook', gem_id: gem.id})} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; title=&quot;Facebook&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-indigo-100 dark:hover:bg-indigo-700 text-[#1877F2] transition-colors&quot; aria-label=&quot;Condividi su Facebook&quot;&gt;&#10;                      &lt;FacebookIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/a&gt;&#10;                    &lt;button onClick={()=&gt;{handleCopyLink(); trackEvent('share',{channel:'instagram_copy', gem_id: gem.id});}} title=&quot;Instagram (copia link)&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-pink-100 dark:hover:bg-pink-700 text-pink-500 transition-colors&quot; aria-label=&quot;Condividi su Instagram (copia link)&quot;&gt;&#10;                      &lt;InstagramIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/button&gt;&#10;                    &lt;a href={whatsappUrl} onClick={()=&gt;trackEvent('share',{channel:'whatsapp', gem_id: gem.id})} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; title=&quot;WhatsApp&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-emerald-100 dark:hover:bg-emerald-700 text-emerald-500 transition-colors&quot; aria-label=&quot;Condividi su WhatsApp&quot;&gt;&#10;                      &lt;WhatsappIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/a&gt;&#10;                    &lt;a href={emailUrl} onClick={()=&gt;trackEvent('share',{channel:'email', gem_id: gem.id})} title=&quot;Email&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-blue-100 dark:hover:bg-blue-700 text-indigo-500 transition-colors&quot; aria-label=&quot;Condividi via Email&quot;&gt;&#10;                      &lt;MailIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/a&gt;&#10;                    &lt;button onClick={handleCopyLink} title=&quot;Copia link&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-300 transition-colors&quot; aria-label=&quot;Copia link&quot;&gt;&#10;                      &lt;CopyIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;&#10;                {gem.tags &amp;&amp; gem.tags.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;mt-4 flex flex-wrap gap-2 items-center&quot;&gt;&#10;                        &lt;TagIcon className=&quot;w-5 h-5 text-slate-400 dark:text-slate-500&quot;/&gt;&#10;                        {gem.tags.map(tag =&gt; (&#10;                            &lt;button &#10;                                key={tag} &#10;                                onClick={() =&gt; onTagSelect(tag)}&#10;                                className=&quot;px-2.5 py-1 bg-slate-100 dark:bg-slate-700 text-slate-600 dark:text-slate-300 rounded-full text-xs font-semibold hover:bg-slate-200 dark:hover:bg-slate-600 transition-colors&quot;&#10;                            &gt;&#10;                                {tag}&#10;                            &lt;/button&gt;&#10;                        ))}&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {/* Tabs Tips / Saggio */}&#10;                &lt;div className=&quot;mt-8 flex justify-end&quot;&gt;&#10;                  &lt;div className=&quot;inline-flex items-center gap-1 rounded-full bg-slate-100 dark:bg-slate-800 p-1 shadow-inner ring-1 ring-slate-200/60 dark:ring-slate-700/60&quot;&gt;&#10;                    &lt;button&#10;                      onClick={() =&gt; setActiveTab('tips')}&#10;                      aria-pressed={activeTab==='tips'}&#10;                      title=&quot;Vista Tips (strutturata)&quot;&#10;                      className={`relative flex items-center justify-center w-9 h-9 rounded-full transition-all focus:outline-none focus:ring-2 focus:ring-indigo-400 dark:focus:ring-indigo-500 group ${activeTab==='tips' ? 'bg-gradient-to-tr from-indigo-500 to-violet-500 text-white shadow-md' : 'text-slate-500 dark:text-slate-400 hover:text-indigo-600 dark:hover:text-indigo-300'}`}&#10;                    &gt;&#10;                      &lt;LightBulbIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                      {activeTab==='tips' &amp;&amp; &lt;span className=&quot;absolute -bottom-1 h-1 w-4 rounded-full bg-white/70 dark:bg-white/40&quot;/&gt;}&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                      onClick={() =&gt; setActiveTab('saggio')}&#10;                      aria-pressed={activeTab==='saggio'}&#10;                      title=&quot;Vista Saggio (testo completo)&quot;&#10;                      className={`relative flex items-center justify-center w-9 h-9 rounded-full transition-all focus:outline-none focus:ring-2 focus:ring-indigo-400 dark:focus:ring-indigo-500 group ${activeTab==='saggio' ? 'bg-gradient-to-tr from-indigo-500 to-violet-500 text-white shadow-md' : 'text-slate-500 dark:text-slate-400 hover:text-indigo-600 dark:hover:text-indigo-300'}`}&#10;                    &gt;&#10;                      &lt;BookOpenIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                      {activeTab==='saggio' &amp;&amp; &lt;span className=&quot;absolute -bottom-1 h-1 w-4 rounded-full bg-white/70 dark:bg-white/40&quot;/&gt;}&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;mt-6 relative&quot; style={{ height: contentHeight ? contentHeight : undefined }}&gt;&#10;                  {/* Pannello Tips */}&#10;                  &lt;div&#10;                    ref={tipsRef}&#10;                    className={`absolute inset-0 transition-opacity duration-400 ease-in-out ${activeTab==='tips' ? 'opacity-100' : 'opacity-0 pointer-events-none'} overflow-visible`}&#10;                  &gt;&#10;                    {(() =&gt; { const structuredContent = renderStructuredContent(); return structuredContent ? structuredContent : (&#10;                      &lt;p className=&quot;text-slate-700 dark:text-slate-300 leading-relaxed whitespace-pre-wrap&quot;&gt;{fullDescription || ''}&lt;/p&gt;&#10;                    ); })()}&#10;                  &lt;/div&gt;&#10;                  {/* Pannello Saggio */}&#10;                  &lt;div&#10;                    ref={saggioRef}&#10;                    className={`absolute inset-0 transition-opacity duration-400 ease-in-out ${activeTab==='saggio' ? 'opacity-100' : 'opacity-0 pointer-events-none'} overflow-visible`}&#10;                  &gt;&#10;                    {fullDescription ? (&#10;                      paragraphs.length &gt; 0 ? (&#10;                        &lt;div className=&quot;prose prose-slate dark:prose-invert max-w-none&quot;&gt;&#10;                          {readingTime &amp;&amp; (&#10;                            &lt;div className=&quot;mb-6 flex items-center text-xs uppercase tracking-wide text-slate-500 dark:text-slate-400 gap-3&quot;&gt;&#10;                              &lt;span className=&quot;inline-flex items-center px-2 py-1 rounded-full bg-slate-200 dark:bg-slate-700 text-slate-600 dark:text-slate-300 font-semibold&quot;&gt;⏱ {readingTime.display}&lt;/span&gt;&#10;                              &lt;span className=&quot;text-slate-400 dark:text-slate-500&quot;&gt;{readingTime.words} parole&lt;/span&gt;&#10;                            &lt;/div&gt;&#10;                          )}&#10;                          {paragraphs.map((p, i) =&gt; {&#10;                            const isKey = p.includes(':') || /—/.test(p);&#10;                            return (&#10;                              &lt;p&#10;                                key={i}&#10;                                className={`text-base md:text-lg leading-relaxed md:leading-loose tracking-[0.015em] text-slate-700 dark:text-slate-300 text-justify hyphens-auto break-words mb-5 last:mb-0 ${i===0 ? 'first-letter:text-4xl first-letter:font-semibold first-letter:float-left first-letter:mr-2 first-letter:mt-1 first-letter:leading-[0.9]' : ''} ${isKey ? 'border-l-2 border-indigo-300 dark:border-indigo-500 pl-3 bg-indigo-50/40 dark:bg-indigo-500/5 rounded-sm' : ''}`}&#10;                                style={{ hyphens: 'auto' }}&#10;                              &gt;&#10;                                {p}&#10;                              &lt;/p&gt;&#10;                            );&#10;                          })}&#10;                        &lt;/div&gt;&#10;                      ) : (&#10;                        &lt;p className=&quot;text-slate-700 dark:text-slate-300 leading-relaxed whitespace-pre-wrap&quot;&gt;{fullDescription}&lt;/p&gt;&#10;                      )&#10;                    ) : (&#10;                      &lt;p className=&quot;italic text-slate-500 dark:text-slate-400&quot;&gt;Nessun testo disponibile.&lt;/p&gt;&#10;                    )}&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Fonti */}&#10;                {(() =&gt; { const sources = (gem as any).search_results &amp;&amp; (gem as any).search_results.length &gt; 0 ? (gem as any).search_results : gem.sources; return sources &amp;&amp; sources.length &gt; 0 &amp;&amp; (&#10;                    &lt;section className=&quot;mt-10 border-t border-slate-200 dark:border-slate-700 pt-6&quot;&gt;&#10;                         &lt;button&#10;                            onClick={() =&gt; setIsSourcesOpen(!isSourcesOpen)}&#10;                            className=&quot;w-full flex justify-between items-center text-left&quot;&#10;                            aria-expanded={isSourcesOpen}&#10;                         &gt;&#10;                            &lt;h2 className=&quot;text-lg font-bold text-slate-900 dark:text-white flex items-center&quot;&gt;&#10;                                &lt;LinkIcon className=&quot;w-5 h-5 mr-2 text-slate-500&quot;/&gt;&#10;                                Fonti&#10;                            &lt;/h2&gt;&#10;                            &lt;ChevronDownIcon className={`w-5 h-5 text-slate-500 transition-transform ${isSourcesOpen ? 'rotate-180' : ''}`} /&gt;&#10;                        &lt;/button&gt;&#10;                        {isSourcesOpen &amp;&amp; (&#10;                            &lt;ul className=&quot;mt-3 space-y-2&quot;&gt;&#10;                                {sources.map((source: any, index: number) =&gt; (&#10;                                    &lt;li key={index}&gt;&#10;                                        &lt;a &#10;                                            href={source.uri} &#10;                                            target=&quot;_blank&quot; &#10;                                            rel=&quot;noopener noreferrer&quot; &#10;                                            className=&quot;text-sm text-indigo-600 dark:text-indigo-400 hover:underline break-all&quot;&#10;                                        &gt;&#10;                                        {index+1}. {source.title || source.uri}&#10;                                        &lt;/a&gt;&#10;                                    &lt;/li&gt;&#10;                                ))}&#10;                            &lt;/ul&gt;&#10;                        )}&#10;                    &lt;/section&gt;&#10;                ); })()}&#10;            &lt;/div&gt;&#10;        &lt;/article&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default GemDetailView;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useRef } from 'react';&#10;import { Gem, UserQuestion, User, Filter, Channel } from '../types';&#10;import { ChevronLeftIcon, HeartIcon, ShareIcon, PaperAirplaneIcon, SparklesIcon, PlusCircleIcon, TagIcon, LinkIcon, ChevronDownIcon, LightBulbIcon, BookOpenIcon, FacebookIcon, InstagramIcon, WhatsappIcon, MailIcon, CopyIcon } from './icons';&#10;import { trackEvent, getIdToken } from '../services/firebase';&#10;import { usePageMeta } from '../hooks/usePageMeta';&#10;import Header from './Header';&#10;import { fetchGeneratedQuestionsByGem } from '../services/firestoreService';&#10;import SectionQuestionsChat from './SectionQuestionsChat';&#10;&#10;interface GemDetailViewProps {&#10;  gem: Gem;&#10;  isFavorite: boolean;&#10;  isLoggedIn: boolean;&#10;  user?: User | null;&#10;  onBack: () =&gt; void;&#10;  onSaveRequest: (gemId: string) =&gt; void;&#10;  onRemoveRequest: (gemId: string) =&gt; void;&#10;  onAddUserQuestion: (gemId: string, question: string) =&gt; void;&#10;  onTagSelect: (tag: string) =&gt; void;&#10;  onLogin: () =&gt; void;&#10;  onLogout: () =&gt; void;&#10;  onNavigate: (view: 'feed' | 'saved' | 'profile' | 'dashboard' | 'topics') =&gt; void;&#10;  selectedFilter?: Filter;&#10;  onSelectFilter?: (filter: Filter) =&gt; void;&#10;  channels?: Channel[];&#10;}&#10;&#10;const UserQuestionItem: React.FC&lt;{ userQuestion: UserQuestion }&gt; = ({ userQuestion }) =&gt; (&#10;    &lt;div className=&quot;mt-4 p-4 bg-slate-100 dark:bg-slate-800 rounded-lg&quot;&gt;&#10;        &lt;p className=&quot;font-semibold text-sm text-slate-600 dark:text-slate-300&quot;&gt;Domanda: &lt;span className=&quot;font-normal&quot;&gt;{userQuestion.question}&lt;/span&gt;&lt;/p&gt;&#10;        &lt;div className=&quot;mt-2 text-sm text-slate-800 dark:text-slate-200&quot;&gt;&#10;            {userQuestion.isGenerating ? (&#10;                 &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;                    &lt;SparklesIcon className=&quot;w-4 h-4 animate-pulse text-indigo-400&quot; /&gt;&#10;                    &lt;span&gt;Generazione risposta...&lt;/span&gt;&#10;                &lt;/div&gt;&#10;            ) : (&#10;                &lt;p className=&quot;whitespace-pre-wrap&quot;&gt;{userQuestion.answer}&lt;/p&gt;&#10;            )}&#10;        &lt;/div&gt;&#10;    &lt;/div&gt;&#10;);&#10;&#10;const GemDetailView: React.FC&lt;GemDetailViewProps&gt; = ({ gem, isFavorite, onBack, onSaveRequest, onRemoveRequest, onAddUserQuestion, onTagSelect, isLoggedIn, user, onLogin, onLogout, onNavigate, selectedFilter, onSelectFilter, channels }) =&gt; {&#10;  const [userQuestion, setUserQuestion] = useState('');&#10;  const [isSourcesOpen, setIsSourcesOpen] = useState(false);&#10;  const [hasAutoScrolled, setHasAutoScrolled] = useState(false);&#10;  const imgRef = useRef&lt;HTMLImageElement | null&gt;(null);&#10;  // nuovo stato per tab&#10;  const [activeTab, setActiveTab] = useState&lt;'tips' | 'saggio'&gt;('tips');&#10;  // refs per animazione cross-fade&#10;  const tipsRef = useRef&lt;HTMLDivElement | null&gt;(null);&#10;  const saggioRef = useRef&lt;HTMLDivElement | null&gt;(null);&#10;  const [contentHeight, setContentHeight] = useState&lt;number&gt;(0);&#10;  const [showShareBar, setShowShareBar] = useState(false);&#10;  const [generatedQuestions, setGeneratedQuestions] = useState&lt;(any)[]&gt;([]);&#10;  const [generalChatOpen, setGeneralChatOpen] = useState(false);&#10;  const [generalAutoQId, setGeneralAutoQId] = useState&lt;string | undefined&gt;(undefined);&#10;  const [generalAutoCustom, setGeneralAutoCustom] = useState&lt;string | undefined&gt;(undefined);&#10;  const [generalCustomInput, setGeneralCustomInput] = useState('');&#10;&#10;  const currentUrl = typeof window !== 'undefined' ? `${window.location.origin}/gem/${gem.id}` : '';&#10;  const rawSummary: string = (gem as any)?.content?.summary || '';&#10;  const rawDescription: string = (gem as any)?.content?.description || '';&#10;  const baseText = rawSummary || rawDescription;&#10;  const descriptionSnippet = baseText ? baseText.replace(/\s+/g,' ').slice(0,180) : 'Gemme di conoscenza su Curiow.';&#10;  const shareText = `Scopri questa gemma su Curiow: ${gem.title}`;&#10;&#10;  usePageMeta({&#10;    title: `${gem.title} | Curiow`,&#10;    description: descriptionSnippet,&#10;    image: gem.imageUrl,&#10;    url: currentUrl,&#10;    type: 'article'&#10;  });&#10;&#10;  const handleCopyLink = async () =&gt; {&#10;    try {&#10;      await navigator.clipboard.writeText(currentUrl);&#10;    } catch {&#10;      const tmp = document.createElement('input');&#10;      tmp.value = currentUrl; document.body.appendChild(tmp); tmp.select(); document.execCommand('copy'); document.body.removeChild(tmp);&#10;    }&#10;    trackEvent('share', { channel: 'copy_link', gem_id: gem.id });&#10;    alert('Link copiato!');&#10;  };&#10;&#10;  const handleNativeShare = async () =&gt; {&#10;    if (navigator.share) {&#10;      trackEvent('share_attempt', { channel: 'web_share', gem_id: gem.id });&#10;      try {&#10;        await navigator.share({ title: gem.title, text: shareText, url: currentUrl });&#10;        trackEvent('share', { channel: 'web_share', gem_id: gem.id });&#10;      } catch { /* annullato */ }&#10;    } else {&#10;      handleCopyLink();&#10;    }&#10;  };&#10;&#10;  const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(currentUrl)}`;&#10;  const whatsappUrl = `https://api.whatsapp.com/send?text=${encodeURIComponent(shareText + ' ' + currentUrl)}`;&#10;  const emailUrl = `mailto:?subject=${encodeURIComponent('Consiglio: ' + gem.title)}&amp;body=${encodeURIComponent(shareText + '\n' + currentUrl)}`;&#10;  // Instagram non ha share URL web: fallback copia link&#10;&#10;  // funzione misura altezza contenuto attivo&#10;  const measureActiveHeight = () =&gt; {&#10;    const el = activeTab === 'tips' ? tipsRef.current : saggioRef.current;&#10;    if (el) {&#10;      // usa scrollHeight per includere overflow&#10;      const h = el.scrollHeight;&#10;      setContentHeight(h);&#10;    }&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    // misura dopo cambio tab / gem&#10;    requestAnimationFrame(() =&gt; measureActiveHeight());&#10;  }, [activeTab, gem.id]);&#10;&#10;  useEffect(() =&gt; {&#10;    // misura al resize per mantenere altezza coerente&#10;    const onResize = () =&gt; measureActiveHeight();&#10;    window.addEventListener('resize', onResize);&#10;    return () =&gt; window.removeEventListener('resize', onResize);&#10;  }, []);&#10;&#10;  // Funzione per scrollare il titolo allineandolo appena sotto l'header sticky&#10;  const scrollTitleIntoView = (smooth = false) =&gt; {&#10;    const titleEl = document.getElementById('gem-title');&#10;    if (!titleEl) return;&#10;    const headerEl = document.querySelector('header');&#10;    const headerHeight = headerEl ? (headerEl as HTMLElement).offsetHeight : 0;&#10;    const buffer = 8; // piccolo margine&#10;    const target = titleEl.getBoundingClientRect().top + window.scrollY - headerHeight - buffer;&#10;    window.scrollTo({ top: target &gt;= 0 ? target : 0, behavior: smooth ? 'smooth' : 'auto' });&#10;    setHasAutoScrolled(true);&#10;  };&#10;&#10;  // Scroll iniziale dopo mount/cambio gem (post layout)&#10;  useEffect(() =&gt; {&#10;    setHasAutoScrolled(false);&#10;    // Usa rAF per attendere layout, poi ulteriore timeout breve per carichi asincroni minimi&#10;    requestAnimationFrame(() =&gt; {&#10;      scrollTitleIntoView(false);&#10;      setTimeout(() =&gt; { if (!hasAutoScrolled) scrollTitleIntoView(false); }, 60);&#10;    });&#10;    // eslint-disable-next-line react-hooks/exhaustive-deps&#10;  }, [gem.id]);&#10;&#10;  // Se l'immagine carica dopo e non abbiamo ancora auto-scrollato, riallinea&#10;  const handleImageLoad = () =&gt; {&#10;    if (!hasAutoScrolled) scrollTitleIntoView(false);&#10;  };&#10;&#10;  const handleUserQuestionSubmit = (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (userQuestion.trim()) {&#10;      onAddUserQuestion(gem.id, userQuestion.trim());&#10;      setUserQuestion('');&#10;    }&#10;  };&#10;&#10;  const handleShare = () =&gt; {&#10;    navigator.clipboard.writeText(`Scopri questa gemma di conoscenza: &quot;${gem.title}&quot; su Curiow!`);&#10;    alert(&quot;Contenuto copiato negli appunti!&quot;);&#10;  };&#10;&#10;  const handleFilterSelect = (filter: Filter) =&gt; {&#10;    if (onSelectFilter) onSelectFilter(filter);&#10;    if (filter.type === 'channel') {&#10;      onNavigate('feed');&#10;    }&#10;  };&#10;&#10;  useEffect(()=&gt;{&#10;    let mounted = true;&#10;    fetchGeneratedQuestionsByGem(gem.id).then(qs=&gt;{ if(mounted){ setGeneratedQuestions(qs); } }).catch(e=&gt;console.error('Err fetch questions', e));&#10;    return ()=&gt;{ mounted=false; };&#10;  },[gem.id]);&#10;&#10;  // Funzioni domande per sezione&#10;  const getSectionQuestions = (section: string, stepIndex?: number) =&gt; {&#10;    return generatedQuestions.filter(q =&gt; q.section === section &amp;&amp; (section !== 'step' || q.stepIndex === stepIndex)).slice(0,3);&#10;  };&#10;  const generalQuestions = generatedQuestions.filter(q =&gt; q.section === 'general').slice(0,3);&#10;&#10;  const renderMiniThread = (content: any) =&gt; {&#10;    const steps = Array.isArray(content.steps) ? content.steps : [];&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        &lt;div className=&quot;space-y-4&quot;&gt;&#10;          {steps.map((s: any, idx: number) =&gt; {&#10;            const qs = getSectionQuestions('step', idx);&#10;            return (&#10;              &lt;div key={idx} className=&quot;relative pl-10&quot;&gt;&#10;                &lt;div className=&quot;absolute left-0 top-0 flex flex-col items-center&quot;&gt;&#10;                  &lt;div className=&quot;w-8 h-8 rounded-full bg-indigo-600 text-white flex items-center justify-center text-sm font-semibold shadow&quot;&gt;{idx+1}&lt;/div&gt;&#10;                  {idx &lt; steps.length -1 &amp;&amp; &lt;div className=&quot;flex-1 w-px bg-gradient-to-b from-indigo-400 via-indigo-300 to-transparent mt-1&quot;/&gt;}&#10;                &lt;/div&gt;&#10;                {qs.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;absolute right-2 top-2&quot;&gt;&#10;                    &lt;SectionQuestionsChat gemId={gem.id} elementName=&quot;step&quot; elementIndex={idx} questions={qs} /&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;                &lt;h3 className=&quot;text-lg font-semibold text-slate-900 dark:text-white&quot;&gt;{s.title}&lt;/h3&gt;&#10;                &lt;p className=&quot;mt-1 text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{s.body}&lt;/p&gt;&#10;              &lt;/div&gt;&#10;            );&#10;          })}&#10;        &lt;/div&gt;&#10;        {content.payoff &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-emerald-500/10 via-emerald-500/5 to-indigo-500/10 border border-emerald-400/30 dark:border-emerald-400/20 relative&quot;&gt;&#10;            {getSectionQuestions('payoff').length &gt; 0 &amp;&amp; (&#10;              &lt;div className=&quot;absolute right-2 top-2&quot;&gt;&#10;                &lt;SectionQuestionsChat gemId={gem.id} elementName=&quot;payoff&quot; questions={getSectionQuestions('payoff')} /&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;div className=&quot;flex items-start&quot;&gt;&#10;              &lt;SparklesIcon className=&quot;w-6 h-6 text-emerald-500 mr-3 mt-0.5&quot;/&gt;&#10;              &lt;div&gt;&#10;                &lt;p className=&quot;text-sm uppercase tracking-wide font-semibold text-emerald-600 dark:text-emerald-400&quot;&gt;Payoff&lt;/p&gt;&#10;                &lt;p className=&quot;mt-1 font-medium text-slate-900 dark:text-slate-100 leading-relaxed&quot;&gt;{content.payoff}&lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderMythVsReality = (content: any) =&gt; {&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        &lt;div className=&quot;grid md:grid-cols-2 gap-4&quot;&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-800 relative&quot;&gt;&#10;            {getSectionQuestions('myth').length &gt; 0 &amp;&amp; (&#10;              &lt;div className=&quot;absolute right-2 top-2&quot;&gt;&#10;                &lt;SectionQuestionsChat gemId={gem.id} elementName=&quot;myth&quot; questions={getSectionQuestions('myth')} /&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-rose-600 dark:text-rose-300&quot;&gt;Mito&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 text-rose-800 dark:text-rose-200 font-medium leading-relaxed whitespace-pre-wrap&quot;&gt;{content.myth}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800 relative overflow-hidden&quot;&gt;&#10;            {getSectionQuestions('reality').length &gt; 0 &amp;&amp; (&#10;              &lt;div className=&quot;absolute right-2 top-2&quot;&gt;&#10;                &lt;SectionQuestionsChat gemId={gem.id} elementName=&quot;reality&quot; questions={getSectionQuestions('reality')} /&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;div className=&quot;absolute inset-0 pointer-events-none bg-[radial-gradient(circle_at_80%_20%,rgba(16,185,129,0.15),transparent_60%)]&quot;/&gt;&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-emerald-600 dark:text-emerald-300&quot;&gt;Realtà&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 text-emerald-800 dark:text-emerald-200 font-medium leading-relaxed whitespace-pre-wrap&quot;&gt;{content.reality}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        {content.evidence &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 relative&quot;&gt;&#10;            {getSectionQuestions('evidence').length &gt; 0 &amp;&amp; (&#10;              &lt;div className=&quot;absolute right-2 top-2&quot;&gt;&#10;                &lt;SectionQuestionsChat gemId={gem.id} elementName=&quot;evidence&quot; questions={getSectionQuestions('evidence')} /&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400&quot;&gt;Evidenze&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.evidence}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.why_it_matters &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-indigo-500/10 via-violet-500/10 to-fuchsia-500/10 border border-indigo-300/30 dark:border-indigo-300/20 relative&quot;&gt;&#10;            {getSectionQuestions('why_it_matters').length &gt; 0 &amp;&amp; (&#10;              &lt;div className=&quot;absolute right-2 top-2&quot;&gt;&#10;                &lt;SectionQuestionsChat gemId={gem.id} elementName=&quot;why_it_matters&quot; questions={getSectionQuestions('why_it_matters')} /&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-indigo-600 dark:text-indigo-300&quot;&gt;Perché conta&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 font-medium text-slate-900 dark:text-slate-100 leading-relaxed whitespace-pre-wrap&quot;&gt;{content.why_it_matters}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderFactCard = (content: any) =&gt; {&#10;    const facts: string[] = Array.isArray(content.facts) ? content.facts : [];&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-5&quot;&gt;&#10;        {content.hook &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-br from-indigo-600 to-violet-600 text-white shadow&quot;&gt;&#10;            &lt;p className=&quot;text-sm font-semibold tracking-wide uppercase opacity-90&quot;&gt;Dato Chiave&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-lg leading-snug font-bold whitespace-pre-wrap&quot;&gt;{content.hook}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {facts.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;grid gap-3&quot;&gt;&#10;            {facts.map((f, i) =&gt; (&#10;              &lt;div key={i} className=&quot;p-4 rounded-lg bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 flex&quot;&gt;&#10;                &lt;div className=&quot;mr-3 mt-0.5 text-indigo-500 font-semibold text-xs&quot;&gt;FACT {i+1}&lt;/div&gt;&#10;                &lt;p className=&quot;text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{f}&lt;/p&gt;&#10;              &lt;/div&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.implication &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-amber-700 dark:text-amber-300&quot;&gt;Implicazione&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-amber-900 dark:text-amber-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.implication}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.action &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-emerald-700 dark:text-emerald-300&quot;&gt;Azione&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm font-medium text-emerald-900 dark:text-emerald-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.action}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderProsCons = (content: any) =&gt; {&#10;    const pros: string[] = Array.isArray(content.pros) ? content.pros : [];&#10;    const cons: string[] = Array.isArray(content.cons) ? content.cons : [];&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        {content.scenario &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400&quot;&gt;Scenario&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.scenario}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        &lt;div className=&quot;grid md:grid-cols-2 gap-4&quot;&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-emerald-700 dark:text-emerald-300&quot;&gt;Pro&lt;/p&gt;&#10;            &lt;ul className=&quot;mt-2 space-y-2 text-sm text-emerald-900 dark:text-emerald-100&quot;&gt;&#10;              {pros.map((p,i)=&gt;(&lt;li key={i} className=&quot;flex&quot;&gt;&lt;span className=&quot;mr-2 text-emerald-500 font-semibold&quot;&gt;+&lt;/span&gt;&lt;span className=&quot;flex-1 whitespace-pre-wrap leading-relaxed&quot;&gt;{p}&lt;/span&gt;&lt;/li&gt;))}&#10;              {pros.length===0 &amp;&amp; &lt;li className=&quot;text-emerald-700/70 dark:text-emerald-300/60 italic&quot;&gt;Nessun pro indicato.&lt;/li&gt;}&#10;            &lt;/ul&gt;&#10;          &lt;/div&gt;&#10;          &lt;div className=&quot;p-5 rounded-xl bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-800&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-bold uppercase tracking-wide text-rose-700 dark:text-rose-300&quot;&gt;Contro&lt;/p&gt;&#10;            &lt;ul className=&quot;mt-2 space-y-2 text-sm text-rose-900 dark:text-rose-100&quot;&gt;&#10;              {cons.map((c,i)=&gt;(&lt;li key={i} className=&quot;flex&quot;&gt;&lt;span className=&quot;mr-2 text-rose-500 font-semibold&quot;&gt;-&lt;/span&gt;&lt;span className=&quot;flex-1 whitespace-pre-wrap leading-relaxed&quot;&gt;{c}&lt;/span&gt;&lt;/li&gt;))}&#10;              {cons.length===0 &amp;&amp; &lt;li className=&quot;text-rose-700/70 dark:text-rose-300/60 italic&quot;&gt;Nessun contro indicato.&lt;/li&gt;}&#10;            &lt;/ul&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;        {content.advice &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-indigo-500/10 via-sky-500/10 to-emerald-500/10 border border-indigo-300/30 dark:border-indigo-300/20&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-indigo-600 dark:text-indigo-300&quot;&gt;Sintesi / Consiglio&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 font-medium text-slate-900 dark:text-slate-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.advice}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderQuickExplainer = (content: any) =&gt; {&#10;    return (&#10;      &lt;div className=&quot;mt-6 space-y-6&quot;&gt;&#10;        {content.analogy &amp;&amp; (&#10;          &lt;div className=&quot;p-5 rounded-xl bg-indigo-600 text-white shadow&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide opacity-80&quot;&gt;Analogia Guida&lt;/p&gt;&#10;            &lt;p className=&quot;mt-2 text-lg font-bold leading-snug whitespace-pre-wrap&quot;&gt;{content.analogy}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        {content.definition &amp;&amp; (&#10;          &lt;div className=&quot;p-4 rounded-lg bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400&quot;&gt;Definizione&lt;/p&gt;&#10;            &lt;p className=&quot;mt-1 text-sm text-slate-700 dark:text-slate-300 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.definition}&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;        &lt;div className=&quot;grid md:grid-cols-2 gap-4&quot;&gt;&#10;          {content.example &amp;&amp; (&#10;            &lt;div className=&quot;p-4 rounded-lg bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-200 dark:border-emerald-800&quot;&gt;&#10;              &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-emerald-700 dark:text-emerald-300&quot;&gt;Esempio&lt;/p&gt;&#10;              &lt;p className=&quot;mt-1 text-sm text-emerald-900 dark:text-emerald-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.example}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;          {content.anti_example &amp;&amp; (&#10;            &lt;div className=&quot;p-4 rounded-lg bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-800&quot;&gt;&#10;              &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-rose-700 dark:text-rose-300&quot;&gt;Non È Questo&lt;/p&gt;&#10;              &lt;p className=&quot;mt-1 text-sm text-rose-900 dark:text-rose-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.anti_example}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;        &lt;/div&gt;&#10;        {content.takeaway &amp;&amp; (&#10;            &lt;div className=&quot;p-5 rounded-xl bg-gradient-to-r from-fuchsia-500/10 via-violet-500/10 to-indigo-500/10 border border-fuchsia-300/30 dark:border-fuchsia-300/20&quot;&gt;&#10;              &lt;p className=&quot;text-xs font-semibold uppercase tracking-wide text-fuchsia-600 dark:text-fuchsia-300&quot;&gt;Takeaway&lt;/p&gt;&#10;              &lt;p className=&quot;mt-2 font-medium text-slate-900 dark:text-slate-100 whitespace-pre-wrap leading-relaxed&quot;&gt;{content.takeaway}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    );&#10;  };&#10;&#10;  const renderStructuredContent = () =&gt; {&#10;    const content = (gem as any).content;&#10;    if (!content || !content.template) return null;&#10;    switch (content.template) {&#10;      case 'mini_thread':&#10;        return renderMiniThread(content);&#10;      case 'myth_vs_reality':&#10;        return renderMythVsReality(content);&#10;      case 'fact_card':&#10;        return renderFactCard(content);&#10;      case 'pros_cons':&#10;        return renderProsCons(content);&#10;      case 'quick_explainer':&#10;        return renderQuickExplainer(content);&#10;      default:&#10;        return null;&#10;    }&#10;  };&#10;  // --- fine rendering contenuti template ---&#10;&#10;  // Testo completo del saggio (nuovo: può essere in gem.content.description)&#10;  const fullDescription: string | undefined = (gem as any)?.content?.description;&#10;&#10;  // Utility: segmentazione in paragrafi leggibili (solo visualizzazione)&#10;  const buildParagraphs = (text?: string): string[] =&gt; {&#10;    if (!text) return [];&#10;    const normalized = text.replace(/\r\n?/g, '\n').trim();&#10;    // Se l'autore ha già usato paragrafi (doppie newline) rispetta quelli&#10;    const explicit = normalized.split(/\n{2,}/).map(p =&gt; p.trim()).filter(Boolean);&#10;    if (explicit.length &gt; 1) return explicit;&#10;    // Altrimenti suddividi per punto + spazio + Maiuscola (mantieni il punto)&#10;    const periodSplit = normalized&#10;      // comprime whitespace multiplo a singolo spazio per consistenza&#10;      .replace(/\n+/g, ' ')&#10;      .replace(/\s{2,}/g, ' ')&#10;      .split(/(?&lt;=\.)\s+(?=[A-ZÀ-ÖØ-Ý])/)&#10;      .map(s =&gt; s.trim())&#10;      .filter(Boolean);&#10;    if (periodSplit.length &gt; 1) return periodSplit;&#10;    // fallback: ritorna intero blocco&#10;    return [normalized];&#10;  };&#10;&#10;  const paragraphs = buildParagraphs(fullDescription);&#10;&#10;  // Calcolo tempo di lettura (200 wpm medio)&#10;  const readingTime = (() =&gt; {&#10;    if (!fullDescription) return null;&#10;    const words = fullDescription.trim().split(/\s+/).filter(Boolean).length;&#10;    const WPM = 200; // media adulti IT&#10;    const minutesFloat = words / WPM;&#10;    const minutes = Math.floor(minutesFloat);&#10;    const seconds = Math.round((minutesFloat - minutes) * 60);&#10;    const display = minutes &lt; 1 ? `${seconds &lt; 10 ? '~15s' : `${seconds}s`}` : `${minutes} min${minutes === 1 ? '' : ''}${seconds &gt;= 30 &amp;&amp; minutes &lt; 10 ? ' +' : ''}`;&#10;    return { words, minutes, seconds, display };&#10;  })();&#10;&#10;  useEffect(() =&gt; {&#10;    // Log JWT Firebase solo per admin quando si accede al dettaglio di una gemma&#10;    if (user?.role === 'admin') { // confronto stringa per evitare dipendenza aggiuntiva da enum&#10;      getIdToken()&#10;        .then(token =&gt; {&#10;          if (token) {&#10;            console.log('[ADMIN][JWT] Firebase ID Token:', token);&#10;          } else {&#10;            console.log('[ADMIN][JWT] Nessun token disponibile.');&#10;          }&#10;        })&#10;        .catch(err =&gt; console.warn('[ADMIN][JWT] Errore recupero token:', err));&#10;    }&#10;  }, [user?.role, gem.id]);&#10;&#10;  return (&#10;    &lt;div className=&quot;max-w-2xl mx-auto&quot;&gt;&#10;        &lt;Header&#10;          isLoggedIn={isLoggedIn}&#10;          user={user}&#10;          onLogin={onLogin}&#10;          onLogout={onLogout}&#10;          onNavigate={onNavigate}&#10;          showFilters={true}&#10;          selectedFilter={selectedFilter}&#10;          onSelectFilter={handleFilterSelect}&#10;          channels={channels}&#10;          initialFiltersOpen={false}&#10;          onBack={onBack}&#10;        /&gt;&#10;        &lt;article&gt;&#10;            &lt;div className=&quot;p-5 sm:p-8&quot;&gt;&#10;                {/* Immagine prima */}&#10;                &lt;img ref={imgRef} src={gem.imageUrl} alt={gem.title} onLoad={handleImageLoad} className=&quot;w-full h-auto object-cover md:rounded-lg&quot; /&gt;&#10;                {/* Titolo sotto immagine (ancora) */}&#10;                &lt;h1 id=&quot;gem-title&quot; className=&quot;mt-4 text-2xl lg:text-3xl font-bold text-slate-900 dark:text-white leading-tight&quot;&gt;{gem.title}&lt;/h1&gt;&#10;&#10;                &lt;div className=&quot;mt-4 flex flex-wrap gap-x-4 gap-y-2 items-center&quot;&gt;&#10;                    &lt;button&#10;                        onClick={() =&gt; isFavorite ? onRemoveRequest(gem.id) : onSaveRequest(gem.id)}&#10;                        className=&quot;flex items-center space-x-1.5 text-slate-600 dark:text-slate-300 hover:text-red-500 dark:hover:text-red-400 transition-colors&quot;&#10;                    &gt;&#10;                        &lt;HeartIcon className={`w-6 h-6 ${isFavorite ? 'fill-red-500 text-red-500' : ''}`} /&gt;&#10;                        &lt;span className=&quot;text-sm font-medium&quot;&gt;{isFavorite ? 'Rimuovi' : 'Salva'}&lt;/span&gt;&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                        onClick={()=&gt; setShowShareBar(v=&gt;{const nv=!v; trackEvent('share_bar_toggle',{ open: nv, gem_id: gem.id }); return nv;})}&#10;                        className=&quot;flex items-center space-x-1.5 text-slate-600 dark:text-slate-300 hover:text-indigo-500 dark:hover:text-indigo-400 transition-colors&quot;&#10;                    &gt;&#10;                        &lt;ShareIcon className=&quot;w-6 h-6&quot; /&gt;&#10;                        &lt;span className=&quot;text-sm font-medium&quot;&gt;Condividi&lt;/span&gt;&#10;                    &lt;/button&gt;&#10;                    {navigator.share &amp;&amp; (&#10;                      &lt;button&#10;                        onClick={handleNativeShare}&#10;                        className=&quot;hidden sm:inline-flex items-center space-x-1.5 text-slate-500 dark:text-slate-400 hover:text-indigo-500 dark:hover:text-indigo-400 text-xs&quot;&#10;                      &gt;&#10;                        &lt;span&gt;Share rapido&lt;/span&gt;&#10;                      &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;                {showShareBar &amp;&amp; (&#10;                  &lt;div className=&quot;mt-3 flex flex-wrap gap-2 items-center animate-fade-in&quot;&gt;&#10;                    &lt;a href={facebookUrl} onClick={()=&gt;trackEvent('share',{channel:'facebook', gem_id: gem.id})} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; title=&quot;Facebook&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-indigo-100 dark:hover:bg-indigo-700 text-[#1877F2] transition-colors&quot; aria-label=&quot;Condividi su Facebook&quot;&gt;&#10;                      &lt;FacebookIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/a&gt;&#10;                    &lt;button onClick={()=&gt;{handleCopyLink(); trackEvent('share',{channel:'instagram_copy', gem_id: gem.id});}} title=&quot;Instagram (copia link)&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-pink-100 dark:hover:bg-pink-700 text-pink-500 transition-colors&quot; aria-label=&quot;Condividi su Instagram (copia link)&quot;&gt;&#10;                      &lt;InstagramIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/button&gt;&#10;                    &lt;a href={whatsappUrl} onClick={()=&gt;trackEvent('share',{channel:'whatsapp', gem_id: gem.id})} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; title=&quot;WhatsApp&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-emerald-100 dark:hover:bg-emerald-700 text-emerald-500 transition-colors&quot; aria-label=&quot;Condividi su WhatsApp&quot;&gt;&#10;                      &lt;WhatsappIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/a&gt;&#10;                    &lt;a href={emailUrl} onClick={()=&gt;trackEvent('share',{channel:'email', gem_id: gem.id})} title=&quot;Email&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-blue-100 dark:hover:bg-blue-700 text-indigo-500 transition-colors&quot; aria-label=&quot;Condividi via Email&quot;&gt;&#10;                      &lt;MailIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/a&gt;&#10;                    &lt;button onClick={handleCopyLink} title=&quot;Copia link&quot; className=&quot;p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-300 transition-colors&quot; aria-label=&quot;Copia link&quot;&gt;&#10;                      &lt;CopyIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;&#10;                {gem.tags &amp;&amp; gem.tags.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;mt-4 flex flex-wrap gap-2 items-center&quot;&gt;&#10;                        &lt;TagIcon className=&quot;w-5 h-5 text-slate-400 dark:text-slate-500&quot;/&gt;&#10;                        {gem.tags.map(tag =&gt; (&#10;                            &lt;button &#10;                                key={tag} &#10;                                onClick={() =&gt; onTagSelect(tag)}&#10;                                className=&quot;px-2.5 py-1 bg-slate-100 dark:bg-slate-700 text-slate-600 dark:text-slate-300 rounded-full text-xs font-semibold hover:bg-slate-200 dark:hover:bg-slate-600 transition-colors&quot;&#10;                            &gt;&#10;                                {tag}&#10;                            &lt;/button&gt;&#10;                        ))}&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {/* Tabs Tips / Saggio */}&#10;                &lt;div className=&quot;mt-8 flex justify-end&quot;&gt;&#10;                  &lt;div className=&quot;inline-flex items-center gap-1 rounded-full bg-slate-100 dark:bg-slate-800 p-1 shadow-inner ring-1 ring-slate-200/60 dark:ring-slate-700/60&quot;&gt;&#10;                    &lt;button&#10;                      onClick={() =&gt; setActiveTab('tips')}&#10;                      aria-pressed={activeTab==='tips'}&#10;                      title=&quot;Vista Tips (strutturata)&quot;&#10;                      className={`relative flex items-center justify-center w-9 h-9 rounded-full transition-all focus:outline-none focus:ring-2 focus:ring-indigo-400 dark:focus:ring-indigo-500 group ${activeTab==='tips' ? 'bg-gradient-to-tr from-indigo-500 to-violet-500 text-white shadow-md' : 'text-slate-500 dark:text-slate-400 hover:text-indigo-600 dark:hover:text-indigo-300'}`}&#10;                    &gt;&#10;                      &lt;LightBulbIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                      {activeTab==='tips' &amp;&amp; &lt;span className=&quot;absolute -bottom-1 h-1 w-4 rounded-full bg-white/70 dark:bg-white/40&quot;/&gt;}&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                      onClick={() =&gt; setActiveTab('saggio')}&#10;                      aria-pressed={activeTab==='saggio'}&#10;                      title=&quot;Vista Saggio (testo completo)&quot;&#10;                      className={`relative flex items-center justify-center w-9 h-9 rounded-full transition-all focus:outline-none focus:ring-2 focus:ring-indigo-400 dark:focus:ring-indigo-500 group ${activeTab==='saggio' ? 'bg-gradient-to-tr from-indigo-500 to-violet-500 text-white shadow-md' : 'text-slate-500 dark:text-slate-400 hover:text-indigo-600 dark:hover:text-indigo-300'}`}&#10;                    &gt;&#10;                      &lt;BookOpenIcon className=&quot;w-5 h-5&quot; /&gt;&#10;                      {activeTab==='saggio' &amp;&amp; &lt;span className=&quot;absolute -bottom-1 h-1 w-4 rounded-full bg-white/70 dark:bg-white/40&quot;/&gt;}&#10;                    &lt;/button&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;mt-6 relative&quot; style={{ height: contentHeight ? contentHeight : undefined }}&gt;&#10;                  {/* Pannello Tips */}&#10;                  &lt;div&#10;                    ref={tipsRef}&#10;                    className={`absolute inset-0 transition-opacity duration-400 ease-in-out ${activeTab==='tips' ? 'opacity-100' : 'opacity-0 pointer-events-none'} overflow-visible`}&#10;                  &gt;&#10;                    {(() =&gt; { const structuredContent = renderStructuredContent(); return structuredContent ? structuredContent : (&#10;                      &lt;p className=&quot;text-slate-700 dark:text-slate-300 leading-relaxed whitespace-pre-wrap&quot;&gt;{fullDescription || ''}&lt;/p&gt;&#10;                    ); })()}&#10;                  &lt;/div&gt;&#10;                  {/* Pannello Saggio */}&#10;                  &lt;div&#10;                    ref={saggioRef}&#10;                    className={`absolute inset-0 transition-opacity duration-400 ease-in-out ${activeTab==='saggio' ? 'opacity-100' : 'opacity-0 pointer-events-none'} overflow-visible`}&#10;                  &gt;&#10;                    {fullDescription ? (&#10;                      paragraphs.length &gt; 0 ? (&#10;                        &lt;div className=&quot;prose prose-slate dark:prose-invert max-w-none&quot;&gt;&#10;                          {readingTime &amp;&amp; (&#10;                            &lt;div className=&quot;mb-6 flex items-center text-xs uppercase tracking-wide text-slate-500 dark:text-slate-400 gap-3&quot;&gt;&#10;                              &lt;span className=&quot;inline-flex items-center px-2 py-1 rounded-full bg-slate-200 dark:bg-slate-700 text-slate-600 dark:text-slate-300 font-semibold&quot;&gt;⏱ {readingTime.display}&lt;/span&gt;&#10;                              &lt;span className=&quot;text-slate-400 dark:text-slate-500&quot;&gt;{readingTime.words} parole&lt;/span&gt;&#10;                            &lt;/div&gt;&#10;                          )}&#10;                          {paragraphs.map((p, i) =&gt; {&#10;                            const isKey = p.includes(':') || /—/.test(p);&#10;                            return (&#10;                              &lt;p&#10;                                key={i}&#10;                                className={`text-base md:text-lg leading-relaxed md:leading-loose tracking-[0.015em] text-slate-700 dark:text-slate-300 text-justify hyphens-auto break-words mb-5 last:mb-0 ${i===0 ? 'first-letter:text-4xl first-letter:font-semibold first-letter:float-left first-letter:mr-2 first-letter:mt-1 first-letter:leading-[0.9]' : ''} ${isKey ? 'border-l-2 border-indigo-300 dark:border-indigo-500 pl-3 bg-indigo-50/40 dark:bg-indigo-500/5 rounded-sm' : ''}`}&#10;                                style={{ hyphens: 'auto' }}&#10;                              &gt;&#10;                                {p}&#10;                              &lt;/p&gt;&#10;                            );&#10;                          })}&#10;                        &lt;/div&gt;&#10;                      ) : (&#10;                        &lt;p className=&quot;text-slate-700 dark:text-slate-300 leading-relaxed whitespace-pre-wrap&quot;&gt;{fullDescription}&lt;/p&gt;&#10;                      )&#10;                    ) : (&#10;                      &lt;p className=&quot;italic text-slate-500 dark:text-slate-400&quot;&gt;Nessun testo disponibile.&lt;/p&gt;&#10;                    )}&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Domande generate */}&#10;                {false &amp;&amp; generatedQuestions.length &gt; 0 &amp;&amp; (&#10;                  &lt;div className=&quot;mt-8&quot;&gt;{/* Blocco disattivato - duplicato */}&lt;/div&gt;&#10;                )}&#10;&#10;                {/* Domande Generali (prima delle fonti) */}&#10;                {generalQuestions.length&gt;0 &amp;&amp; (&#10;                  &lt;section className=&quot;mt-10 border-t border-slate-200 dark:border-slate-700 pt-6 relative space-y-4&quot;&gt;&#10;                    &lt;div&gt;&#10;                      &lt;h2 className=&quot;text-lg font-bold text-slate-900 dark:text-white mb-2 flex items-center&quot;&gt;&lt;LightBulbIcon className=&quot;w-5 h-5 mr-2 text-indigo-500&quot;/&gt;Domande Generali&lt;/h2&gt;&#10;                      &lt;div className=&quot;flex flex-wrap gap-2&quot;&gt;&#10;                        {generalQuestions.map(q =&gt; (&#10;                          &lt;button&#10;                            key={q.id}&#10;                            onClick={() =&gt; {&#10;                              setGeneralAutoCustom(undefined);&#10;                              setGeneralAutoQId(q.id);&#10;                              setGeneralChatOpen(true);&#10;                            }}&#10;                            className=&quot;px-3 py-1.5 text-xs rounded-full border border-indigo-300 dark:border-indigo-600 text-indigo-700 dark:text-indigo-300 bg-indigo-50 dark:bg-indigo-900/30 hover:bg-indigo-100 dark:hover:bg-indigo-800/50 transition-colors&quot;&#10;                          &gt;{q.testo}&lt;/button&gt;&#10;                        ))}&#10;                      &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;div className=&quot;flex gap-2 items-center max-w-md&quot;&gt;&#10;                      &lt;input&#10;                        type=&quot;text&quot;&#10;                        value={generalCustomInput}&#10;                        onChange={e=&gt;setGeneralCustomInput(e.target.value)}&#10;                        placeholder=&quot;Scrivi una tua domanda...&quot;&#10;                        className=&quot;flex-1 px-3 py-2 text-sm rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-700 dark:text-slate-200 focus:outline-none focus:ring-1 focus:ring-indigo-500&quot;&#10;                        onKeyDown={e=&gt;{ if(e.key==='Enter' &amp;&amp; generalCustomInput.trim()){ setGeneralAutoQId(undefined); setGeneralAutoCustom(generalCustomInput.trim()); setGeneralChatOpen(true); } }}&#10;                      /&gt;&#10;                      &lt;button&#10;                        onClick={()=&gt;{ if(!generalCustomInput.trim()) return; setGeneralAutoQId(undefined); setGeneralAutoCustom(generalCustomInput.trim()); setGeneralChatOpen(true); }}&#10;                        disabled={!generalCustomInput.trim()}&#10;                        className=&quot;px-4 py-2 text-sm rounded-md bg-indigo-600 disabled:opacity-40 text-white hover:bg-indigo-700 transition&quot;&#10;                      &gt;Chiedi&lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                    {/* Chat controllata */}&#10;                    &lt;div className=&quot;relative&quot;&gt;&#10;                      &lt;SectionQuestionsChat&#10;                        gemId={gem.id}&#10;                        elementName=&quot;general&quot;&#10;                        questions={generalQuestions}&#10;                        hideTrigger&#10;                        externalOpen={generalChatOpen}&#10;                        onOpenChange={(o)=&gt;{ setGeneralChatOpen(o); if(!o){ setGeneralAutoQId(undefined); setGeneralAutoCustom(undefined);} }}&#10;                        autoQuestionId={generalAutoQId}&#10;                        autoCustomQuestionText={generalAutoCustom}&#10;                      /&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/section&gt;&#10;                )}&#10;&#10;                {/* Fonti */}&#10;                {(() =&gt; { const sources = (gem as any).search_results &amp;&amp; (gem as any).search_results.length &gt; 0 ? (gem as any).search_results : gem.sources; return sources &amp;&amp; sources.length &gt; 0 &amp;&amp; (&#10;                    &lt;section className=&quot;mt-10 border-t border-slate-200 dark:border-slate-700 pt-6&quot;&gt;&#10;                         &lt;button&#10;                            onClick={() =&gt; setIsSourcesOpen(!isSourcesOpen)}&#10;                            className=&quot;w-full flex justify-between items-center text-left&quot;&#10;                            aria-expanded={isSourcesOpen}&#10;                         &gt;&#10;                            &lt;h2 className=&quot;text-lg font-bold text-slate-900 dark:text-white flex items-center&quot;&gt;&#10;                                &lt;LinkIcon className=&quot;w-5 h-5 mr-2 text-slate-500&quot;/&gt;&#10;                                Fonti&#10;                            &lt;/h2&gt;&#10;                            &lt;ChevronDownIcon className={`w-5 h-5 text-slate-500 transition-transform ${isSourcesOpen ? 'rotate-180' : ''}`} /&gt;&#10;                        &lt;/button&gt;&#10;                        {isSourcesOpen &amp;&amp; (&#10;                            &lt;ul className=&quot;mt-3 space-y-2&quot;&gt;&#10;                                {sources.map((source: any, index: number) =&gt; (&#10;                                    &lt;li key={index}&gt;&#10;                                        &lt;a &#10;                                            href={source.uri} &#10;                                            target=&quot;_blank&quot; &#10;                                            rel=&quot;noopener noreferrer&quot; &#10;                                            className=&quot;text-sm text-indigo-600 dark:text-indigo-400 hover:underline break-all&quot;&#10;                                        &gt;&#10;                                        {index+1}. {source.title || source.uri}&#10;                                        &lt;/a&gt;&#10;                                    &lt;/li&gt;&#10;                                ))}&#10;                            &lt;/ul&gt;&#10;                        )}&#10;                    &lt;/section&gt;&#10;                ); })()}&#10;            &lt;/div&gt;&#10;        &lt;/article&gt;&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default GemDetailView;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/SectionQuestionsChat.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/SectionQuestionsChat.tsx" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useRef } from 'react';&#10;import { callCuriowApi } from '../services/apiService';&#10;import { LightBulbIcon, SparklesIcon } from './icons';&#10;&#10;export interface SectionQuestionData {&#10;  id: string;&#10;  testo: string;&#10;  tipologia?: string;&#10;}&#10;&#10;interface SectionQuestionsChatProps {&#10;  gemId: string;&#10;  elementName: string; // es: 'step','myth','reality','evidence','why_it_matters','general','payoff'&#10;  elementIndex?: number; // per step&#10;  questions: SectionQuestionData[];&#10;  buttonSize?: 'sm' | 'md';&#10;  align?: 'left' | 'right';&#10;  hideTrigger?: boolean; // se true non mostra l'icona, usato per generale&#10;  externalOpen?: boolean; // stato controllato esterno&#10;  onOpenChange?: (open: boolean) =&gt; void;&#10;  autoQuestionId?: string; // domanda pre-selezionata da chiedere all'apertura&#10;  autoCustomQuestionText?: string; // testo custom da chiedere all'apertura&#10;}&#10;&#10;interface QAState {&#10;  loading: boolean;&#10;  answer?: string;&#10;  error?: string;&#10;}&#10;&#10;const SectionQuestionsChat: React.FC&lt;SectionQuestionsChatProps&gt; = ({&#10;  gemId,&#10;  elementName,&#10;  elementIndex = 0,&#10;  questions,&#10;  buttonSize='sm',&#10;  align='right',&#10;  hideTrigger=false,&#10;  externalOpen,&#10;  onOpenChange,&#10;  autoQuestionId,&#10;  autoCustomQuestionText&#10;}) =&gt; {&#10;  const isControlled = externalOpen !== undefined;&#10;  const [internalOpen, setInternalOpen] = useState(false);&#10;  const open = isControlled ? !!externalOpen : internalOpen;&#10;  const [answers, setAnswers] = useState&lt;Record&lt;string, QAState&gt;&gt;({});&#10;  const [customInput, setCustomInput] = useState('');&#10;  const [customHistory, setCustomHistory] = useState&lt;{ id: string; question: string; answer?: string; loading: boolean; error?: string }[]&gt;([]);&#10;  const autoFiredRef = useRef&lt;string | null&gt;(null);&#10;&#10;  if (!questions || questions.length === 0) {&#10;    return hideTrigger ? null : (&#10;      &lt;div className={align==='right'? 'float-right' : ''}&gt;&lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  const triggerClasses = buttonSize === 'sm'&#10;    ? 'w-8 h-8'&#10;    : 'w-10 h-10';&#10;&#10;  const setOpen = (val: boolean) =&gt; {&#10;    if (isControlled) {&#10;      onOpenChange &amp;&amp; onOpenChange(val);&#10;    } else {&#10;      setInternalOpen(val);&#10;    }&#10;  };&#10;&#10;  const ask = async (q: { id: string; testo: string }, isCustom = false) =&gt; {&#10;    const qid = q.id;&#10;    if (!isCustom) {&#10;      setAnswers(prev =&gt; ({ ...prev, [qid]: { ...(prev[qid]||{}), loading: !prev[qid]?.answer, error: undefined } }));&#10;      if (answers[qid]?.answer) {&#10;        return; // già disponibile&#10;      }&#10;    } else {&#10;      setCustomHistory(h =&gt; h.map(item =&gt; item.id === qid ? { ...item, loading: true, error: undefined } : item));&#10;    }&#10;    try {&#10;      const body: any = {&#10;        apitype: 'deep-question',&#10;        gemId,&#10;        questionId: isCustom ? '' : qid,&#10;        questionText: q.testo,&#10;        element: { name: elementName, index: elementIndex }&#10;      };&#10;      const resp = await callCuriowApi(body);&#10;      const answer = resp.answer || resp.result || resp.text || JSON.stringify(resp);&#10;      if (!isCustom) {&#10;        setAnswers(prev =&gt; ({ ...prev, [qid]: { loading: false, answer } }));&#10;      } else {&#10;        setCustomHistory(h =&gt; h.map(item =&gt; item.id === qid ? { ...item, loading: false, answer } : item));&#10;      }&#10;    } catch (e: any) {&#10;      const msg = e.message || 'Errore';&#10;      if (!isCustom) {&#10;        setAnswers(prev =&gt; ({ ...prev, [qid]: { loading: false, error: msg } }));&#10;      } else {&#10;        setCustomHistory(h =&gt; h.map(item =&gt; item.id === qid ? { ...item, loading: false, error: msg } : item));&#10;      }&#10;    }&#10;  };&#10;&#10;  const sendCustom = () =&gt; {&#10;    const text = customInput.trim();&#10;    if (!text) return;&#10;    const id = 'custom-' + Date.now();&#10;    setCustomHistory(h =&gt; [...h, { id, question: text, loading: true }]);&#10;    setCustomInput('');&#10;    ask({ id, testo: text }, true);&#10;  };&#10;&#10;  // Auto ask quando si apre&#10;  useEffect(() =&gt; {&#10;    if (!open) return;&#10;    const token = `${autoQuestionId||''}|${autoCustomQuestionText||''}`;&#10;    if (!token || token === '|' || autoFiredRef.current === token) return;&#10;    autoFiredRef.current = token;&#10;    if (autoQuestionId) {&#10;      const q = questions.find(q =&gt; q.id === autoQuestionId);&#10;      if (q) ask(q, false);&#10;    } else if (autoCustomQuestionText) {&#10;      const id = 'auto-custom-'+Date.now();&#10;      setCustomHistory(h =&gt; [...h, { id, question: autoCustomQuestionText, loading: true }]);&#10;      ask({ id, testo: autoCustomQuestionText }, true);&#10;    }&#10;  }, [open, autoQuestionId, autoCustomQuestionText, questions]);&#10;&#10;  const panel = open &amp;&amp; (&#10;    &lt;div className={`absolute z-30 mt-2 w-80 max-w-[85vw] ${align==='right' ? 'right-0' : 'left-0'} origin-top-right bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-xl shadow-xl p-4 text-slate-700 dark:text-slate-200 animate-fade-in`}&gt;      &#10;      &lt;div className=&quot;flex items-center justify-between mb-2&quot;&gt;&#10;        &lt;h4 className=&quot;text-xs font-semibold uppercase tracking-wide text-indigo-600 dark:text-indigo-400&quot;&gt;Approfondisci&lt;/h4&gt;&#10;        &lt;button onClick={() =&gt; setOpen(false)} className=&quot;text-slate-400 hover:text-slate-600 dark:hover:text-slate-300 text-sm&quot;&gt;✕&lt;/button&gt;&#10;      &lt;/div&gt;&#10;      &lt;div className=&quot;space-y-2 max-h-56 overflow-y-auto pr-1 custom-scrollbar&quot;&gt;&#10;        {questions.map(q =&gt; {&#10;          const st = answers[q.id];&#10;          return (&#10;            &lt;div key={q.id} className=&quot;border border-slate-200 dark:border-slate-700 rounded-md p-2 bg-slate-50 dark:bg-slate-800/50&quot;&gt;&#10;              &lt;button&#10;                onClick={() =&gt; ask(q)}&#10;                className=&quot;text-left w-full text-xs font-medium text-indigo-700 dark:text-indigo-300 hover:underline&quot;&#10;              &gt;{q.testo}&lt;/button&gt;&#10;              {st?.loading &amp;&amp; &lt;p className=&quot;mt-1 text-[11px] italic text-slate-500 animate-pulse&quot;&gt;Caricamento risposta...&lt;/p&gt;}&#10;              {st?.error &amp;&amp; &lt;p className=&quot;mt-1 text-[11px] text-red-500&quot;&gt;{st.error}&lt;/p&gt;}&#10;              {st?.answer &amp;&amp; &lt;p className=&quot;mt-1 text-[11px] whitespace-pre-wrap leading-relaxed&quot;&gt;{st.answer}&lt;/p&gt;}&#10;            &lt;/div&gt;&#10;          );&#10;        })}&#10;        {customHistory.map(item =&gt; (&#10;          &lt;div key={item.id} className=&quot;border border-slate-200 dark:border-slate-700 rounded-md p-2 bg-slate-50 dark:bg-slate-800/30&quot;&gt;&#10;            &lt;p className=&quot;text-xs font-medium text-slate-600 dark:text-slate-300&quot;&gt;{item.question}&lt;/p&gt;&#10;            {item.loading &amp;&amp; &lt;p className=&quot;mt-1 text-[11px] italic text-slate-500 animate-pulse&quot;&gt;Caricamento...&lt;/p&gt;}&#10;            {item.error &amp;&amp; &lt;p className=&quot;mt-1 text-[11px] text-red-500&quot;&gt;{item.error}&lt;/p&gt;}&#10;            {item.answer &amp;&amp; &lt;p className=&quot;mt-1 text-[11px] whitespace-pre-wrap leading-relaxed&quot;&gt;{item.answer}&lt;/p&gt;}&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;      &lt;div className=&quot;mt-3 pt-2 border-t border-slate-200 dark:border-slate-700&quot;&gt;&#10;        &lt;div className=&quot;flex gap-2&quot;&gt;&#10;          &lt;input&#10;            type=&quot;text&quot;&#10;            value={customInput}&#10;            onChange={e =&gt; setCustomInput(e.target.value)}&#10;            placeholder=&quot;Fai una domanda...&quot;&#10;            className=&quot;flex-1 px-2 py-1.5 rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-xs focus:outline-none focus:ring-1 focus:ring-indigo-500&quot;&#10;            onKeyDown={e =&gt; { if (e.key === 'Enter') sendCustom(); }}&#10;          /&gt;&#10;          &lt;button&#10;            onClick={sendCustom}&#10;            disabled={!customInput.trim()}&#10;            className=&quot;px-2.5 py-1.5 rounded-md bg-indigo-600 disabled:opacity-40 text-white text-xs hover:bg-indigo-700 transition&quot;&#10;          &gt;Invia&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;&#10;  return (&#10;    &lt;div className={`relative inline-block ${align === 'right' ? 'float-right' : ''}`}&gt;&#10;      {!hideTrigger &amp;&amp; (&#10;        &lt;button&#10;          type=&quot;button&quot;&#10;            onClick={() =&gt; setOpen(!open)}&#10;          className={`group ${triggerClasses} rounded-full flex items-center justify-center bg-indigo-600/90 hover:bg-indigo-600 text-white shadow transition focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-400`}&#10;          title=&quot;Domande / Approfondisci&quot;&#10;        &gt;&#10;          &lt;SparklesIcon className={`w-4 h-4 ${open ? 'animate-pulse' : ''}`} /&gt;&#10;        &lt;/button&gt;&#10;      )}&#10;      {panel}&#10;    &lt;/div&gt;&#10;  );&#10;};&#10;&#10;export default SectionQuestionsChat;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/firestoreService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/firestoreService.ts" />
              <option name="originalContent" value="import {&#10;  collection,&#10;  doc,&#10;  getDocs,&#10;  getDoc,&#10;  setDoc,&#10;  updateDoc,&#10;  addDoc,&#10;  deleteDoc,&#10;  query,&#10;  limit,&#10;  onSnapshot,&#10;  Unsubscribe,&#10;  orderBy,&#10;  where,&#10;  writeBatch,&#10;  startAfter,&#10;  QueryDocumentSnapshot,&#10;  DocumentData&#10;} from 'firebase/firestore';&#10;import { db } from './firebase';&#10;import { Gem, Channel, User, SavedList, UserQuestion, UserRole, TopicSuggestion, ListWithItems } from '../types';&#10;import { getDefaultPermissions } from './roleService';&#10;import * as listService from './listService';&#10;&#10;// --- Fetch Operations ---&#10;&#10;export const fetchChannels = async (): Promise&lt;Channel[]&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const channelSnapshot = await getDocs(channelsCollection);&#10;    return channelSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as Channel));&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching channels:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const fetchGems = async (maxCount: number = 20): Promise&lt;Gem[]&gt; =&gt; {&#10;    try {&#10;        const gemsCollection = collection(db, 'gems');&#10;        const q = query(gemsCollection, limit(maxCount));&#10;        const gemSnapshot = await getDocs(q);&#10;        return gemSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data(), userQuestions: [] } as Gem));&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching gems:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const fetchUserProfile = async (uid: string): Promise&lt;User | null&gt; =&gt; {&#10;    try {&#10;        const userDocRef = doc(db, 'users', uid);&#10;        const userDoc = await getDoc(userDocRef);&#10;        return userDoc.exists() ? (userDoc.data() as User) : null;&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching user profile:&quot;, error);&#10;        return null;&#10;    }&#10;};&#10;&#10;export const fetchUserSavedLists = async (uid: string): Promise&lt;SavedList[]&gt; =&gt; {&#10;    try {&#10;        const userDocRef = doc(db, 'users', uid);&#10;        const userDoc = await getDoc(userDocRef);&#10;        if (userDoc.exists() &amp;&amp; userDoc.data().savedLists) {&#10;            return userDoc.data().savedLists;&#10;        }&#10;        return [];&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching user saved lists:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;&#10;// --- Write Operations ---&#10;&#10;export const createUserProfile = async (uid: string, email: string, firstName: string, lastName: string, role: UserRole = UserRole.USER): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', uid);&#10;    const defaultLists: SavedList[] = [&#10;        { id: 'default', name: 'Preferiti Generici', gemIds: [] }&#10;    ];&#10;    const permissions = getDefaultPermissions(role);&#10;&#10;    await setDoc(userDocRef, {&#10;        email, &#10;        firstName, &#10;        lastName,&#10;        role,&#10;        permissions,&#10;        createdAt: new Date(),&#10;        lastLoginAt: new Date(),&#10;        savedLists: defaultLists&#10;    });&#10;};&#10;&#10;export const updateUserProfile = async (uid: string, data: Partial&lt;User&gt;): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', uid);&#10;    await updateDoc(userDocRef, data);&#10;};&#10;&#10;export const updateUserSavedLists = async (uid:string, lists: SavedList[]): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', uid);&#10;    await updateDoc(userDocRef, { savedLists: lists });&#10;};&#10;&#10;export const addUserQuestion = async (gemId: string, question: string): Promise&lt;void&gt; =&gt; {&#10;    const questionsCollection = collection(db, 'gems', gemId, 'userQuestions');&#10;    await addDoc(questionsCollection, {&#10;        question,&#10;        answer: '',&#10;        isGenerating: true,&#10;        createdAt: new Date(),&#10;    });&#10;};&#10;&#10;&#10;// --- Listeners ---&#10;&#10;export const listenToUserQuestions = (gemId: string, callback: (questions: UserQuestion[]) =&gt; void): Unsubscribe =&gt; {&#10;    const questionsCollection = collection(db, 'gems', gemId, 'userQuestions');&#10;    const q = query(questionsCollection, orderBy('createdAt', 'desc'));&#10;    &#10;    return onSnapshot(q, (snapshot) =&gt; {&#10;        const questions = snapshot.docs.map(doc =&gt; ({&#10;            id: doc.id,&#10;            ...doc.data()&#10;        } as UserQuestion));&#10;        callback(questions);&#10;    });&#10;};&#10;&#10;// --- Topic Suggestions Operations ---&#10;&#10;export const fetchTopicSuggestions = async (status?: 'pending' | 'approved' | 'converted'): Promise&lt;TopicSuggestion[]&gt; =&gt; {&#10;    try {&#10;        const topicsCollection = collection(db, 'topic_suggestions');&#10;        let q = query(topicsCollection, orderBy('createdAt', 'desc'));&#10;&#10;        if (status) {&#10;            q = query(topicsCollection, where('status', '==', status), orderBy('createdAt', 'desc'));&#10;        }&#10;&#10;        const topicSnapshot = await getDocs(q);&#10;        // Filtra gli elementi eliminati lato client per evitare problemi con indici Firestore&#10;        const topics = topicSnapshot.docs&#10;            .map(doc =&gt; ({ id: doc.id, ...doc.data() } as TopicSuggestion))&#10;            .filter(topic =&gt; !topic.deleted); // Filtra solo quelli che hanno deleted = true&#10;&#10;        return topics;&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching topic suggestions:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const createTopicSuggestion = async (&#10;  title: string,&#10;  objective: string,&#10;  tags: string[],&#10;  createdBy: string,&#10;  originalSuggestion?: string,&#10;  channelId?: string&#10;): Promise&lt;void&gt; =&gt; {&#10;  const topicsCollection = collection(db, 'topic_suggestions');&#10;  await addDoc(topicsCollection, {&#10;    title,&#10;    objective,&#10;    originalSuggestion: originalSuggestion || '',&#10;    tags,&#10;    createdBy,&#10;    channelId: channelId || '',&#10;    status: 'pending',&#10;    createdAt: new Date(),&#10;    updatedAt: new Date(),&#10;  });&#10;};&#10;&#10;export const updateTopicSuggestion = async (id: string, data: Partial&lt;TopicSuggestion&gt;): Promise&lt;void&gt; =&gt; {&#10;    const topicDocRef = doc(db, 'topic_suggestions', id);&#10;    await updateDoc(topicDocRef, { ...data, updatedAt: new Date() });&#10;};&#10;&#10;export const deleteTopicSuggestion = async (id: string): Promise&lt;void&gt; =&gt; {&#10;    const topicDocRef = doc(db, 'topic_suggestions', id);&#10;    await updateDoc(topicDocRef, { deleted: true, updatedAt: new Date() });&#10;};&#10;&#10;// --- User Management Operations ---&#10;&#10;export const fetchAllUsers = async (limit?: number): Promise&lt;(User &amp; { id: string })[]&gt; =&gt; {&#10;    try {&#10;        const usersCollection = collection(db, 'users');&#10;        let q = query(usersCollection, orderBy('createdAt', 'desc'));&#10;&#10;        if (limit) {&#10;            q = query(usersCollection, orderBy('createdAt', 'desc'), limit(limit));&#10;        }&#10;&#10;        const userSnapshot = await getDocs(q);&#10;        return userSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as User &amp; { id: string }));&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching users:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const searchUsers = async (searchTerm: string): Promise&lt;(User &amp; { id: string })[]&gt; =&gt; {&#10;    try {&#10;        // Nota: Firestore non supporta ricerca full-text nativa, quindi facciamo una ricerca per email&#10;        const usersCollection = collection(db, 'users');&#10;        const q = query(&#10;            usersCollection,&#10;            where('email', '&gt;=', searchTerm.toLowerCase()),&#10;            where('email', '&lt;=', searchTerm.toLowerCase() + '\uf8ff')&#10;        );&#10;&#10;        const userSnapshot = await getDocs(q);&#10;        return userSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as User &amp; { id: string }));&#10;    } catch (error) {&#10;        console.error(&quot;Error searching users:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const promoteUserRole = async (userId: string, newRole: UserRole): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', userId);&#10;    const newPermissions = getDefaultPermissions(newRole);&#10;&#10;    await updateDoc(userDocRef, {&#10;        role: newRole,&#10;        permissions: newPermissions,&#10;        updatedAt: new Date()&#10;    });&#10;};&#10;&#10;// --- Nuove funzioni per gestione liste (con retrocompatibilità) ---&#10;&#10;export const fetchUserListsNew = async (uid: string): Promise&lt;ListWithItems[]&gt; =&gt; {&#10;    try {&#10;        // Prima prova a caricare le liste dalla nuova struttura&#10;        const newLists = await listService.fetchUserLists(uid);&#10;&#10;        if (newLists.length &gt; 0) {&#10;            console.log('Found lists in new structure:', newLists.length);&#10;            return newLists;&#10;        }&#10;&#10;        // Se non ci sono liste nella nuova struttura, controlla le vecchie&#10;        const oldLists = await fetchUserSavedLists(uid);&#10;        console.log('Found old lists:', oldLists.length);&#10;&#10;        if (oldLists.length &gt; 0) {&#10;            // Converti le vecchie liste nel formato nuovo per compatibilità UI&#10;            const convertedLists = oldLists.map(oldList =&gt; ({&#10;                id: oldList.id,&#10;                name: oldList.name,&#10;                isPublic: false,&#10;                createdBy: uid,&#10;                createdAt: new Date(),&#10;                updatedAt: new Date(),&#10;                gemIds: oldList.gemIds,&#10;                itemCount: oldList.gemIds.length,&#10;                userRole: 'owner' as const&#10;            }));&#10;&#10;            console.log('Converted old lists to new format:', convertedLists);&#10;            return convertedLists;&#10;        }&#10;&#10;        // Se non ci sono liste né vecchie né nuove, ritorna array vuoto&#10;        console.log('No lists found for user:', uid);&#10;        return [];&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching user lists:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;// Funzioni wrapper per compatibilità con l'UI esistente&#10;export const createNewList = async (uid: string, name: string): Promise&lt;string&gt; =&gt; {&#10;    return await listService.createList(name, uid);&#10;};&#10;&#10;export const addGemToUserList = async (uid: string, listId: string, gemId: string): Promise&lt;void&gt; =&gt; {&#10;    // Prima verifica se è una lista vecchia o nuova&#10;    const newLists = await listService.fetchUserLists(uid);&#10;    const isNewList = newLists.some(list =&gt; list.id === listId);&#10;&#10;    if (isNewList) {&#10;        await listService.addGemToList(listId, gemId, uid);&#10;    } else {&#10;        // Gestisci le vecchie liste (retrocompatibilità durante migrazione)&#10;        const oldLists = await fetchUserSavedLists(uid);&#10;        const listIndex = oldLists.findIndex(list =&gt; list.id === listId);&#10;&#10;        if (listIndex !== -1 &amp;&amp; !oldLists[listIndex].gemIds.includes(gemId)) {&#10;            oldLists[listIndex].gemIds.push(gemId);&#10;            await updateUserSavedLists(uid, oldLists);&#10;        }&#10;    }&#10;};&#10;&#10;export const removeGemFromUserList = async (uid: string, listId: string, gemId: string): Promise&lt;void&gt; =&gt; {&#10;    // Prima verifica se è una lista vecchia o nuova&#10;    const newLists = await listService.fetchUserLists(uid);&#10;    const isNewList = newLists.some(list =&gt; list.id === listId);&#10;&#10;    if (isNewList) {&#10;        await listService.removeGemFromList(listId, gemId);&#10;    } else {&#10;        // Gestisci le vecchie liste (retrocompatibilità durante migrazione)&#10;        const oldLists = await fetchUserSavedLists(uid);&#10;        const listIndex = oldLists.findIndex(list =&gt; list.id === listId);&#10;&#10;        if (listIndex !== -1) {&#10;            oldLists[listIndex].gemIds = oldLists[listIndex].gemIds.filter(id =&gt; id !== gemId);&#10;            await updateUserSavedLists(uid, oldLists);&#10;        }&#10;    }&#10;};&#10;&#10;// Esporta le funzioni del nuovo servizio liste per uso diretto&#10;export const {&#10;    createList,&#10;    addGemToList,&#10;    removeGemFromList,&#10;    fetchUserLists,&#10;    fetchListById,&#10;    updateList,&#10;    deleteList,&#10;    addMemberToList,&#10;    removeMemberFromList,&#10;    checkGemInList&#10;} = listService;&#10;&#10;// --- Channel Operations ---&#10;&#10;export const fetchAllChannels = async (): Promise&lt;(Channel &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const q = query(channelsCollection, orderBy('createdAt', 'desc'));&#10;    const channelSnapshot = await getDocs(q);&#10;    return channelSnapshot.docs.map(doc =&gt; ({&#10;      id: doc.id,&#10;      ...doc.data(),&#10;      createdAt: doc.data().createdAt?.toDate() || new Date()&#10;    } as Channel &amp; { id: string }));&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching all channels:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const createChannel = async (channelData: Omit&lt;Channel, 'id' | 'createdAt'&gt;): Promise&lt;string&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const docRef = await addDoc(channelsCollection, {&#10;      ...channelData,&#10;      createdAt: new Date()&#10;    });&#10;    return docRef.id;&#10;  } catch (error) {&#10;    console.error(&quot;Error creating channel:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const updateChannel = async (channelId: string, channelData: Partial&lt;Channel&gt;): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    const channelDocRef = doc(db, 'channels', channelId);&#10;    await updateDoc(channelDocRef, {&#10;      ...channelData,&#10;      updatedAt: new Date()&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error updating channel:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const deleteChannel = async (channelId: string): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    const channelDocRef = doc(db, 'channels', channelId);&#10;    await updateDoc(channelDocRef, {&#10;      isActive: false,&#10;      deletedAt: new Date()&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting channel:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const searchChannels = async (searchTerm: string): Promise&lt;(Channel &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const channelSnapshot = await getDocs(channelsCollection);&#10;    const allChannels = channelSnapshot.docs.map(doc =&gt; ({&#10;      id: doc.id,&#10;      ...doc.data(),&#10;      createdAt: doc.data().createdAt?.toDate() || new Date()&#10;    } as Channel &amp; { id: string }));&#10;&#10;    // Filtro lato client per la ricerca&#10;    return allChannels.filter(c =&gt; (c as any).name?.toLowerCase().includes(searchTerm.toLowerCase()));&#10;  } catch (error) {&#10;    console.error(&quot;Error searching channels:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;// --- Questions (AI generated) ---&#10;export interface GeneratedQuestionRecord {&#10;  createdAt: string; // ISO&#10;  gemId: string;&#10;  section: string;&#10;  testo: string;&#10;  tipologia: string;&#10;  stepIndex?: number;&#10;}&#10;&#10;export const addGeneratedQuestion = async (qData: GeneratedQuestionRecord): Promise&lt;string&gt; =&gt; {&#10;  try {&#10;    const questionsCollection = collection(db, 'questions');&#10;    const docRef = await addDoc(questionsCollection, qData);&#10;    return docRef.id;&#10;  } catch (error) {&#10;    console.error('Errore salvataggio domanda generata:', error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const fetchGeneratedQuestionsByGem = async (gemId: string): Promise&lt;GeneratedQuestionRecord[]&gt; =&gt; {&#10;  try {&#10;    const questionsCollection = collection(db, 'questions');&#10;    const q = query(questionsCollection, where('gemId', '==', gemId), orderBy('createdAt', 'asc'));&#10;    const snapshot = await getDocs(q);&#10;    return snapshot.docs.map(d =&gt; d.data() as GeneratedQuestionRecord);&#10;  } catch (error) {&#10;    console.error('Errore fetch domande generate:', error);&#10;    return [];&#10;  }&#10;};&#10;&#10;// Aggiunte funzioni per gestione gems&#10;export const fetchAllGems = async (): Promise&lt;(Gem &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    const q = query(gemsCollection, orderBy('title', 'asc'));&#10;    const gemSnapshot = await getDocs(q);&#10;    return gemSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data(), userQuestions: [] } as Gem &amp; { id: string }));&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching all gems:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const searchGems = async (searchTerm: string): Promise&lt;(Gem &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    const snapshot = await getDocs(gemsCollection);&#10;    const allGems = snapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as Gem &amp; { id: string }));&#10;&#10;    return allGems.filter(gem =&gt; {&#10;      const desc = (gem as any).content?.description || (gem as any).description || '';&#10;      const tags = gem.tags || [];&#10;      return (&#10;        gem.title.toLowerCase().includes(searchTerm.toLowerCase()) ||&#10;        desc.toLowerCase().includes(searchTerm.toLowerCase()) ||&#10;        tags.some(tag =&gt; tag.toLowerCase().includes(searchTerm.toLowerCase()))&#10;      );&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error searching gems:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const createGem = async (gemData: Omit&lt;Gem, 'id'&gt;): Promise&lt;string&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    const docRef = await addDoc(gemsCollection, gemData);&#10;    return docRef.id;&#10;  } catch (error) {&#10;    console.error(&quot;Error creating gem:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const updateGem = async (gemId: string, gemData: Partial&lt;Gem&gt;): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    const gemDocRef = doc(db, 'gems', gemId);&#10;    await updateDoc(gemDocRef, gemData);&#10;  } catch (error) {&#10;    console.error(&quot;Error updating gem:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const deleteGem = async (gemId: string): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    // Elimina il documento principale della gem&#10;    const gemDocRef = doc(db, 'gems', gemId);&#10;    await deleteDoc(gemDocRef);&#10;&#10;    // Trova tutti i list_items che referenziano questa gem&#10;    const itemsQuery = query(&#10;      collection(db, 'list_items'),&#10;      where('gemId', '==', gemId)&#10;    );&#10;    const itemsSnapshot = await getDocs(itemsQuery);&#10;&#10;    if (!itemsSnapshot.empty) {&#10;      // Usiamo batch multipli se necessario per rimanere sotto il limite di 500 operazioni&#10;      let batch = writeBatch(db);&#10;      let ops = 0;&#10;      const affectedListIds = new Set&lt;string&gt;();&#10;&#10;      for (const itemDoc of itemsSnapshot.docs) {&#10;        batch.delete(itemDoc.ref);&#10;        ops++;&#10;        const data: any = itemDoc.data();&#10;        if (data.listId) affectedListIds.add(data.listId);&#10;        if (ops &gt;= 450) { // commit parziale lasciando margine per update liste&#10;          await batch.commit();&#10;          batch = writeBatch(db);&#10;          ops = 0;&#10;        }&#10;      }&#10;&#10;      // Aggiorna updatedAt delle liste toccate&#10;      for (const listId of affectedListIds) {&#10;        batch.update(doc(db, 'lists', listId), { updatedAt: new Date() });&#10;        ops++;&#10;        if (ops &gt;= 450) {&#10;          await batch.commit();&#10;          batch = writeBatch(db);&#10;          ops = 0;&#10;        }&#10;      }&#10;&#10;      if (ops &gt; 0) {&#10;        await batch.commit();&#10;      }&#10;    }&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting gem:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const getGemById = async (gemId: string): Promise&lt;(Gem &amp; { id: string }) | null&gt; =&gt; {&#10;  try {&#10;    const gemDocRef = doc(db, 'gems', gemId);&#10;    const gemDoc = await getDoc(gemDocRef);&#10;    if (gemDoc.exists()) {&#10;      return { id: gemDoc.id, ...gemDoc.data(), userQuestions: [] } as Gem &amp; { id: string };&#10;    }&#10;    return null;&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching gem by id:&quot;, error);&#10;    return null;&#10;  }&#10;};&#10;&#10;export const fetchGemById = async (id: string): Promise&lt;Gem | null&gt; =&gt; {&#10;  try {&#10;    const gemDocRef = doc(db, 'gems', id);&#10;    const gemDoc = await getDoc(gemDocRef);&#10;    if (!gemDoc.exists()) return null;&#10;    return { id: gemDoc.id, ...gemDoc.data(), userQuestions: [] } as Gem;&#10;  } catch (error) {&#10;    console.error('Error fetching gem by id:', error);&#10;    return null;&#10;  }&#10;};&#10;&#10;// --- Funzioni per caricamento paginato delle gems ---&#10;&#10;export const fetchGemsPaginated = async (lastDoc?: QueryDocumentSnapshot&lt;DocumentData&gt;, pageSize: number = 20): Promise&lt;{ gems: Gem[], lastVisible?: QueryDocumentSnapshot&lt;DocumentData&gt; }&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    // Ordinamento stabile: prima per title poi per id documento&#10;    let q = query(gemsCollection, orderBy('title', 'asc'), orderBy('__name__', 'asc'), limit(pageSize));&#10;&#10;    if (lastDoc) {&#10;      q = query(gemsCollection, orderBy('title', 'asc'), orderBy('__name__', 'asc'), startAfter(lastDoc), limit(pageSize));&#10;    }&#10;&#10;    const gemSnapshot = await getDocs(q);&#10;    const gems = gemSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data(), userQuestions: [] } as Gem));&#10;&#10;    return {&#10;      gems,&#10;      lastVisible: gemSnapshot.docs.length &gt; 0 ? gemSnapshot.docs[gemSnapshot.docs.length - 1] : undefined&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching paginated gems:&quot;, error);&#10;    return { gems: [] };&#10;  }&#10;};&#10;" />
              <option name="updatedContent" value="import {&#10;  collection,&#10;  doc,&#10;  getDocs,&#10;  getDoc,&#10;  setDoc,&#10;  updateDoc,&#10;  addDoc,&#10;  deleteDoc,&#10;  query,&#10;  limit,&#10;  onSnapshot,&#10;  Unsubscribe,&#10;  orderBy,&#10;  where,&#10;  writeBatch,&#10;  startAfter,&#10;  QueryDocumentSnapshot,&#10;  DocumentData&#10;} from 'firebase/firestore';&#10;import { db } from './firebase';&#10;import { Gem, Channel, User, SavedList, UserQuestion, UserRole, TopicSuggestion, ListWithItems } from '../types';&#10;import { getDefaultPermissions } from './roleService';&#10;import * as listService from './listService';&#10;&#10;// --- Fetch Operations ---&#10;&#10;export const fetchChannels = async (): Promise&lt;Channel[]&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const channelSnapshot = await getDocs(channelsCollection);&#10;    return channelSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as Channel));&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching channels:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const fetchGems = async (maxCount: number = 20): Promise&lt;Gem[]&gt; =&gt; {&#10;    try {&#10;        const gemsCollection = collection(db, 'gems');&#10;        const q = query(gemsCollection, limit(maxCount));&#10;        const gemSnapshot = await getDocs(q);&#10;        return gemSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data(), userQuestions: [] } as Gem));&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching gems:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const fetchUserProfile = async (uid: string): Promise&lt;User | null&gt; =&gt; {&#10;    try {&#10;        const userDocRef = doc(db, 'users', uid);&#10;        const userDoc = await getDoc(userDocRef);&#10;        return userDoc.exists() ? (userDoc.data() as User) : null;&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching user profile:&quot;, error);&#10;        return null;&#10;    }&#10;};&#10;&#10;export const fetchUserSavedLists = async (uid: string): Promise&lt;SavedList[]&gt; =&gt; {&#10;    try {&#10;        const userDocRef = doc(db, 'users', uid);&#10;        const userDoc = await getDoc(userDocRef);&#10;        if (userDoc.exists() &amp;&amp; userDoc.data().savedLists) {&#10;            return userDoc.data().savedLists;&#10;        }&#10;        return [];&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching user saved lists:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;&#10;// --- Write Operations ---&#10;&#10;export const createUserProfile = async (uid: string, email: string, firstName: string, lastName: string, role: UserRole = UserRole.USER): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', uid);&#10;    const defaultLists: SavedList[] = [&#10;        { id: 'default', name: 'Preferiti Generici', gemIds: [] }&#10;    ];&#10;    const permissions = getDefaultPermissions(role);&#10;&#10;    await setDoc(userDocRef, {&#10;        email, &#10;        firstName, &#10;        lastName,&#10;        role,&#10;        permissions,&#10;        createdAt: new Date(),&#10;        lastLoginAt: new Date(),&#10;        savedLists: defaultLists&#10;    });&#10;};&#10;&#10;export const updateUserProfile = async (uid: string, data: Partial&lt;User&gt;): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', uid);&#10;    await updateDoc(userDocRef, data);&#10;};&#10;&#10;export const updateUserSavedLists = async (uid:string, lists: SavedList[]): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', uid);&#10;    await updateDoc(userDocRef, { savedLists: lists });&#10;};&#10;&#10;export const addUserQuestion = async (gemId: string, question: string): Promise&lt;void&gt; =&gt; {&#10;    const questionsCollection = collection(db, 'gems', gemId, 'userQuestions');&#10;    await addDoc(questionsCollection, {&#10;        question,&#10;        answer: '',&#10;        isGenerating: true,&#10;        createdAt: new Date(),&#10;    });&#10;};&#10;&#10;&#10;// --- Listeners ---&#10;&#10;export const listenToUserQuestions = (gemId: string, callback: (questions: UserQuestion[]) =&gt; void): Unsubscribe =&gt; {&#10;    const questionsCollection = collection(db, 'gems', gemId, 'userQuestions');&#10;    const q = query(questionsCollection, orderBy('createdAt', 'desc'));&#10;    &#10;    return onSnapshot(q, (snapshot) =&gt; {&#10;        const questions = snapshot.docs.map(doc =&gt; ({&#10;            id: doc.id,&#10;            ...doc.data()&#10;        } as UserQuestion));&#10;        callback(questions);&#10;    });&#10;};&#10;&#10;// --- Topic Suggestions Operations ---&#10;&#10;export const fetchTopicSuggestions = async (status?: 'pending' | 'approved' | 'converted'): Promise&lt;TopicSuggestion[]&gt; =&gt; {&#10;    try {&#10;        const topicsCollection = collection(db, 'topic_suggestions');&#10;        let q = query(topicsCollection, orderBy('createdAt', 'desc'));&#10;&#10;        if (status) {&#10;            q = query(topicsCollection, where('status', '==', status), orderBy('createdAt', 'desc'));&#10;        }&#10;&#10;        const topicSnapshot = await getDocs(q);&#10;        // Filtra gli elementi eliminati lato client per evitare problemi con indici Firestore&#10;        const topics = topicSnapshot.docs&#10;            .map(doc =&gt; ({ id: doc.id, ...doc.data() } as TopicSuggestion))&#10;            .filter(topic =&gt; !topic.deleted); // Filtra solo quelli che hanno deleted = true&#10;&#10;        return topics;&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching topic suggestions:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const createTopicSuggestion = async (&#10;  title: string,&#10;  objective: string,&#10;  tags: string[],&#10;  createdBy: string,&#10;  originalSuggestion?: string,&#10;  channelId?: string&#10;): Promise&lt;void&gt; =&gt; {&#10;  const topicsCollection = collection(db, 'topic_suggestions');&#10;  await addDoc(topicsCollection, {&#10;    title,&#10;    objective,&#10;    originalSuggestion: originalSuggestion || '',&#10;    tags,&#10;    createdBy,&#10;    channelId: channelId || '',&#10;    status: 'pending',&#10;    createdAt: new Date(),&#10;    updatedAt: new Date(),&#10;  });&#10;};&#10;&#10;export const updateTopicSuggestion = async (id: string, data: Partial&lt;TopicSuggestion&gt;): Promise&lt;void&gt; =&gt; {&#10;    const topicDocRef = doc(db, 'topic_suggestions', id);&#10;    await updateDoc(topicDocRef, { ...data, updatedAt: new Date() });&#10;};&#10;&#10;export const deleteTopicSuggestion = async (id: string): Promise&lt;void&gt; =&gt; {&#10;    const topicDocRef = doc(db, 'topic_suggestions', id);&#10;    await updateDoc(topicDocRef, { deleted: true, updatedAt: new Date() });&#10;};&#10;&#10;// --- User Management Operations ---&#10;&#10;export const fetchAllUsers = async (limit?: number): Promise&lt;(User &amp; { id: string })[]&gt; =&gt; {&#10;    try {&#10;        const usersCollection = collection(db, 'users');&#10;        let q = query(usersCollection, orderBy('createdAt', 'desc'));&#10;&#10;        if (limit) {&#10;            q = query(usersCollection, orderBy('createdAt', 'desc'), limit(limit));&#10;        }&#10;&#10;        const userSnapshot = await getDocs(q);&#10;        return userSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as User &amp; { id: string }));&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching users:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const searchUsers = async (searchTerm: string): Promise&lt;(User &amp; { id: string })[]&gt; =&gt; {&#10;    try {&#10;        // Nota: Firestore non supporta ricerca full-text nativa, quindi facciamo una ricerca per email&#10;        const usersCollection = collection(db, 'users');&#10;        const q = query(&#10;            usersCollection,&#10;            where('email', '&gt;=', searchTerm.toLowerCase()),&#10;            where('email', '&lt;=', searchTerm.toLowerCase() + '\uf8ff')&#10;        );&#10;&#10;        const userSnapshot = await getDocs(q);&#10;        return userSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as User &amp; { id: string }));&#10;    } catch (error) {&#10;        console.error(&quot;Error searching users:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;export const promoteUserRole = async (userId: string, newRole: UserRole): Promise&lt;void&gt; =&gt; {&#10;    const userDocRef = doc(db, 'users', userId);&#10;    const newPermissions = getDefaultPermissions(newRole);&#10;&#10;    await updateDoc(userDocRef, {&#10;        role: newRole,&#10;        permissions: newPermissions,&#10;        updatedAt: new Date()&#10;    });&#10;};&#10;&#10;// --- Nuove funzioni per gestione liste (con retrocompatibilità) ---&#10;&#10;export const fetchUserListsNew = async (uid: string): Promise&lt;ListWithItems[]&gt; =&gt; {&#10;    try {&#10;        // Prima prova a caricare le liste dalla nuova struttura&#10;        const newLists = await listService.fetchUserLists(uid);&#10;&#10;        if (newLists.length &gt; 0) {&#10;            console.log('Found lists in new structure:', newLists.length);&#10;            return newLists;&#10;        }&#10;&#10;        // Se non ci sono liste nella nuova struttura, controlla le vecchie&#10;        const oldLists = await fetchUserSavedLists(uid);&#10;        console.log('Found old lists:', oldLists.length);&#10;&#10;        if (oldLists.length &gt; 0) {&#10;            // Converti le vecchie liste nel formato nuovo per compatibilità UI&#10;            const convertedLists = oldLists.map(oldList =&gt; ({&#10;                id: oldList.id,&#10;                name: oldList.name,&#10;                isPublic: false,&#10;                createdBy: uid,&#10;                createdAt: new Date(),&#10;                updatedAt: new Date(),&#10;                gemIds: oldList.gemIds,&#10;                itemCount: oldList.gemIds.length,&#10;                userRole: 'owner' as const&#10;            }));&#10;&#10;            console.log('Converted old lists to new format:', convertedLists);&#10;            return convertedLists;&#10;        }&#10;&#10;        // Se non ci sono liste né vecchie né nuove, ritorna array vuoto&#10;        console.log('No lists found for user:', uid);&#10;        return [];&#10;    } catch (error) {&#10;        console.error(&quot;Error fetching user lists:&quot;, error);&#10;        return [];&#10;    }&#10;};&#10;&#10;// Funzioni wrapper per compatibilità con l'UI esistente&#10;export const createNewList = async (uid: string, name: string): Promise&lt;string&gt; =&gt; {&#10;    return await listService.createList(name, uid);&#10;};&#10;&#10;export const addGemToUserList = async (uid: string, listId: string, gemId: string): Promise&lt;void&gt; =&gt; {&#10;    // Prima verifica se è una lista vecchia o nuova&#10;    const newLists = await listService.fetchUserLists(uid);&#10;    const isNewList = newLists.some(list =&gt; list.id === listId);&#10;&#10;    if (isNewList) {&#10;        await listService.addGemToList(listId, gemId, uid);&#10;    } else {&#10;        // Gestisci le vecchie liste (retrocompatibilità durante migrazione)&#10;        const oldLists = await fetchUserSavedLists(uid);&#10;        const listIndex = oldLists.findIndex(list =&gt; list.id === listId);&#10;&#10;        if (listIndex !== -1 &amp;&amp; !oldLists[listIndex].gemIds.includes(gemId)) {&#10;            oldLists[listIndex].gemIds.push(gemId);&#10;            await updateUserSavedLists(uid, oldLists);&#10;        }&#10;    }&#10;};&#10;&#10;export const removeGemFromUserList = async (uid: string, listId: string, gemId: string): Promise&lt;void&gt; =&gt; {&#10;    // Prima verifica se è una lista vecchia o nuova&#10;    const newLists = await listService.fetchUserLists(uid);&#10;    const isNewList = newLists.some(list =&gt; list.id === listId);&#10;&#10;    if (isNewList) {&#10;        await listService.removeGemFromList(listId, gemId);&#10;    } else {&#10;        // Gestisci le vecchie liste (retrocompatibilità durante migrazione)&#10;        const oldLists = await fetchUserSavedLists(uid);&#10;        const listIndex = oldLists.findIndex(list =&gt; list.id === listId);&#10;&#10;        if (listIndex !== -1) {&#10;            oldLists[listIndex].gemIds = oldLists[listIndex].gemIds.filter(id =&gt; id !== gemId);&#10;            await updateUserSavedLists(uid, oldLists);&#10;        }&#10;    }&#10;};&#10;&#10;// Esporta le funzioni del nuovo servizio liste per uso diretto&#10;export const {&#10;    createList,&#10;    addGemToList,&#10;    removeGemFromList,&#10;    fetchUserLists,&#10;    fetchListById,&#10;    updateList,&#10;    deleteList,&#10;    addMemberToList,&#10;    removeMemberFromList,&#10;    checkGemInList&#10;} = listService;&#10;&#10;// --- Channel Operations ---&#10;&#10;export const fetchAllChannels = async (): Promise&lt;(Channel &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const q = query(channelsCollection, orderBy('createdAt', 'desc'));&#10;    const channelSnapshot = await getDocs(q);&#10;    return channelSnapshot.docs.map(doc =&gt; ({&#10;      id: doc.id,&#10;      ...doc.data(),&#10;      createdAt: doc.data().createdAt?.toDate() || new Date()&#10;    } as Channel &amp; { id: string }));&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching all channels:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const createChannel = async (channelData: Omit&lt;Channel, 'id' | 'createdAt'&gt;): Promise&lt;string&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const docRef = await addDoc(channelsCollection, {&#10;      ...channelData,&#10;      createdAt: new Date()&#10;    });&#10;    return docRef.id;&#10;  } catch (error) {&#10;    console.error(&quot;Error creating channel:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const updateChannel = async (channelId: string, channelData: Partial&lt;Channel&gt;): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    const channelDocRef = doc(db, 'channels', channelId);&#10;    await updateDoc(channelDocRef, {&#10;      ...channelData,&#10;      updatedAt: new Date()&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error updating channel:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const deleteChannel = async (channelId: string): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    const channelDocRef = doc(db, 'channels', channelId);&#10;    await updateDoc(channelDocRef, {&#10;      isActive: false,&#10;      deletedAt: new Date()&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting channel:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const searchChannels = async (searchTerm: string): Promise&lt;(Channel &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const channelsCollection = collection(db, 'channels');&#10;    const channelSnapshot = await getDocs(channelsCollection);&#10;    const allChannels = channelSnapshot.docs.map(doc =&gt; ({&#10;      id: doc.id,&#10;      ...doc.data(),&#10;      createdAt: doc.data().createdAt?.toDate() || new Date()&#10;    } as Channel &amp; { id: string }));&#10;&#10;    // Filtro lato client per la ricerca&#10;    return allChannels.filter(c =&gt; (c as any).name?.toLowerCase().includes(searchTerm.toLowerCase()));&#10;  } catch (error) {&#10;    console.error(&quot;Error searching channels:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;// --- Questions (AI generated) ---&#10;export interface GeneratedQuestionRecord {&#10;  createdAt: string; // ISO&#10;  gemId: string;&#10;  section: string;&#10;  testo: string;&#10;  tipologia: string;&#10;  stepIndex?: number;&#10;}&#10;&#10;export const addGeneratedQuestion = async (qData: GeneratedQuestionRecord): Promise&lt;string&gt; =&gt; {&#10;  try {&#10;    const questionsCollection = collection(db, 'questions');&#10;    const docRef = await addDoc(questionsCollection, qData);&#10;    return docRef.id;&#10;  } catch (error) {&#10;    console.error('Errore salvataggio domanda generata:', error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const fetchGeneratedQuestionsByGem = async (gemId: string): Promise&lt;(GeneratedQuestionRecord &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const questionsCollection = collection(db, 'questions');&#10;    const q = query(questionsCollection, where('gemId', '==', gemId), orderBy('createdAt', 'asc'));&#10;    const snapshot = await getDocs(q);&#10;    return snapshot.docs.map(d =&gt; ({ id: d.id, ...(d.data() as GeneratedQuestionRecord) }));&#10;  } catch (error) {&#10;    console.error('Errore fetch domande generate:', error);&#10;    return [];&#10;  }&#10;};&#10;&#10;// Aggiunte funzioni per gestione gems&#10;export const fetchAllGems = async (): Promise&lt;(Gem &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    const q = query(gemsCollection, orderBy('title', 'asc'));&#10;    const gemSnapshot = await getDocs(q);&#10;    return gemSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data(), userQuestions: [] } as Gem &amp; { id: string }));&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching all gems:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const searchGems = async (searchTerm: string): Promise&lt;(Gem &amp; { id: string })[]&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    const snapshot = await getDocs(gemsCollection);&#10;    const allGems = snapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data() } as Gem &amp; { id: string }));&#10;&#10;    return allGems.filter(gem =&gt; {&#10;      const desc = (gem as any).content?.description || (gem as any).description || '';&#10;      const tags = gem.tags || [];&#10;      return (&#10;        gem.title.toLowerCase().includes(searchTerm.toLowerCase()) ||&#10;        desc.toLowerCase().includes(searchTerm.toLowerCase()) ||&#10;        tags.some(tag =&gt; tag.toLowerCase().includes(searchTerm.toLowerCase()))&#10;      );&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error searching gems:&quot;, error);&#10;    return [];&#10;  }&#10;};&#10;&#10;export const createGem = async (gemData: Omit&lt;Gem, 'id'&gt;): Promise&lt;string&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    const docRef = await addDoc(gemsCollection, gemData);&#10;    return docRef.id;&#10;  } catch (error) {&#10;    console.error(&quot;Error creating gem:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const updateGem = async (gemId: string, gemData: Partial&lt;Gem&gt;): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    const gemDocRef = doc(db, 'gems', gemId);&#10;    await updateDoc(gemDocRef, gemData);&#10;  } catch (error) {&#10;    console.error(&quot;Error updating gem:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const deleteGem = async (gemId: string): Promise&lt;void&gt; =&gt; {&#10;  try {&#10;    // Elimina il documento principale della gem&#10;    const gemDocRef = doc(db, 'gems', gemId);&#10;    await deleteDoc(gemDocRef);&#10;&#10;    // Trova tutti i list_items che referenziano questa gem&#10;    const itemsQuery = query(&#10;      collection(db, 'list_items'),&#10;      where('gemId', '==', gemId)&#10;    );&#10;    const itemsSnapshot = await getDocs(itemsQuery);&#10;&#10;    if (!itemsSnapshot.empty) {&#10;      // Usiamo batch multipli se necessario per rimanere sotto il limite di 500 operazioni&#10;      let batch = writeBatch(db);&#10;      let ops = 0;&#10;      const affectedListIds = new Set&lt;string&gt;();&#10;&#10;      for (const itemDoc of itemsSnapshot.docs) {&#10;        batch.delete(itemDoc.ref);&#10;        ops++;&#10;        const data: any = itemDoc.data();&#10;        if (data.listId) affectedListIds.add(data.listId);&#10;        if (ops &gt;= 450) { // commit parziale lasciando margine per update liste&#10;          await batch.commit();&#10;          batch = writeBatch(db);&#10;          ops = 0;&#10;        }&#10;      }&#10;&#10;      // Aggiorna updatedAt delle liste toccate&#10;      for (const listId of affectedListIds) {&#10;        batch.update(doc(db, 'lists', listId), { updatedAt: new Date() });&#10;        ops++;&#10;        if (ops &gt;= 450) {&#10;          await batch.commit();&#10;          batch = writeBatch(db);&#10;          ops = 0;&#10;        }&#10;      }&#10;&#10;      if (ops &gt; 0) {&#10;        await batch.commit();&#10;      }&#10;    }&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting gem:&quot;, error);&#10;    throw error;&#10;  }&#10;};&#10;&#10;export const getGemById = async (gemId: string): Promise&lt;(Gem &amp; { id: string }) | null&gt; =&gt; {&#10;  try {&#10;    const gemDocRef = doc(db, 'gems', gemId);&#10;    const gemDoc = await getDoc(gemDocRef);&#10;    if (gemDoc.exists()) {&#10;      return { id: gemDoc.id, ...gemDoc.data(), userQuestions: [] } as Gem &amp; { id: string };&#10;    }&#10;    return null;&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching gem by id:&quot;, error);&#10;    return null;&#10;  }&#10;};&#10;&#10;export const fetchGemById = async (id: string): Promise&lt;Gem | null&gt; =&gt; {&#10;  try {&#10;    const gemDocRef = doc(db, 'gems', id);&#10;    const gemDoc = await getDoc(gemDocRef);&#10;    if (!gemDoc.exists()) return null;&#10;    return { id: gemDoc.id, ...gemDoc.data(), userQuestions: [] } as Gem;&#10;  } catch (error) {&#10;    console.error('Error fetching gem by id:', error);&#10;    return null;&#10;  }&#10;};&#10;&#10;// --- Funzioni per caricamento paginato delle gems ---&#10;&#10;export const fetchGemsPaginated = async (lastDoc?: QueryDocumentSnapshot&lt;DocumentData&gt;, pageSize: number = 20): Promise&lt;{ gems: Gem[], lastVisible?: QueryDocumentSnapshot&lt;DocumentData&gt; }&gt; =&gt; {&#10;  try {&#10;    const gemsCollection = collection(db, 'gems');&#10;    // Ordinamento stabile: prima per title poi per id documento&#10;    let q = query(gemsCollection, orderBy('title', 'asc'), orderBy('__name__', 'asc'), limit(pageSize));&#10;&#10;    if (lastDoc) {&#10;      q = query(gemsCollection, orderBy('title', 'asc'), orderBy('__name__', 'asc'), startAfter(lastDoc), limit(pageSize));&#10;    }&#10;&#10;    const gemSnapshot = await getDocs(q);&#10;    const gems = gemSnapshot.docs.map(doc =&gt; ({ id: doc.id, ...doc.data(), userQuestions: [] } as Gem));&#10;&#10;    return {&#10;      gems,&#10;      lastVisible: gemSnapshot.docs.length &gt; 0 ? gemSnapshot.docs[gemSnapshot.docs.length - 1] : undefined&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching paginated gems:&quot;, error);&#10;    return { gems: [] };&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>